---
title: mysql索引优化分析
categories: [mysql,mysql高级]   #分类
tags: [mysql索引]         #标签
toc: true  #是否启用内容索引
top: false #是否置顶 true或者注释
date: 2020-10-25
typora-root-url: ..
---

## 1. 索引优化分析

### 1.1 索引的概念

MySQL 官方对索引的定义为：索引（Index）是帮助MySQL 高效获取数据的数据结构。可以得到索引的本质：**索引是数据结构。可以简单理解为排好序的快速查找数据结构。**

在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：

<img src="/images/mysql/1601024115(1).jpg">

左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。

一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。

### 1.2 优缺点

**优点：**

+   提高数据检索的效率，降低数据库的IO成本。
+   通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。

**缺点：**

+   虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
+   实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要**占用空间**的。


## 2. MySQL索引的数据结构

**B树和B+树**

>   【小细节】 
>
>   B树就是B-tree，’ - ‘ 只是一个符号；B+树其实是B+-tree
>
>   B树是一棵平衡树(AVL树)，而平衡树每次在进行增删改时都会失去平衡，因此就要就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。

### 2.1 B树

**B-Tree的性质**

1、定义任意非叶子结点最多只有M个儿子，且M>2； 
2、根结点的儿子数为[2, M]； 
3、除根结点以外的非叶子结点的儿子数为[M/2, M]； 
4、每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字） 
5、非叶子结点的关键字个数=指向儿子的指针个数-1； 
6、非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] < K[i+1]； 
7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树； 
8、所有叶子结点位于同一层； 



**B树结构如下图：**

![](/images/mysql/1603865296.png)

【介绍】

>   系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来。
>
>   InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。
>
>   InnoDB在把磁盘数据读入到内存时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。

【初始化介绍】

>   一颗b 树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示）；
>
>   如磁盘块1 包含数据项17 和35，包含指针P1、P2、P3，P1 表示小于17 的磁盘块，
>
>   P2 表示在17 和35 之间的磁盘块，P3 表示大于35 的磁盘块。
>
>   真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。
>
>   非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35 并不真实存在于数据表中。如磁盘块1 包含数据项17 和35，包含指针P1、P2、P3



【查找过程】

>   如果要查找数据项29，那么首先会把磁盘块1 由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17 和35 之间，锁定磁盘块1 的P2 指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2 指针的磁盘地址把磁盘块3 由磁盘加载到内存，发生第二次IO，29 在26 和30 之间，锁定磁盘块3 的P2 指针，通过指针加载磁盘块8 到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。
>
>   **真实的情况是，3 层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。**



### 2.2 B+Tree

**B+Tree是在B-Tree基础上的一种优化**，使其更适合实现外存储索引结构，**InnoDB存储引擎就是用B+Tree实现其索引结构**。

B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。

![](/images/mysql/1603952458.png)

**B+Tree相对于B-Tree有几点不同：**

1.  非叶子节点只存储键值信息。
2.  所有叶子节点之间都有一个链指针。
3.  数据记录都存放在叶子节点中。

### 2.3 应用

B和B+树主要用在文件系统以及数据库做索引，比如MySQL；



>   【B/B+树性能】
>
>   在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，**而在实际应用中却是B+树的性能要好些**。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是**一次磁盘访问的时间相当于成百上千次内存比较的时间**，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。



**为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？**

**1、B+树的磁盘读写代价更低**

B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO 读写次数也就降低了。

**2、B+树的查询效率更加稳定**

由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

---

## 3. 聚簇索引与非聚簇索引

聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值聚簇的存储在一起。

如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。

![](/images/mysql/1603955597.jpg)

当表中有聚簇索引时，它的数据实际上存储在索引的叶子页中（叶子页中包含了行的全部数据）。而没有聚簇索引时B+Tree叶子页存放的是指向数据的指针。

>    **（页是mysql存储引擎最小的存储单元，InnoDB每个页默认大小为16k）可以理解为 有聚簇索引时，数据和对应的叶子页在同一页中，没有聚簇索引时，叶子页和对应的数据不在同一页中。**



**聚簇索引的好处：**

+   按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io 操作。
+   数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从举措索引中获取数据通常比非聚簇索引查找更快。

**聚簇索引的限制：**

+   对于mysql 数据库目前**只有innodb 数据引擎支持聚簇索引**，而Myisam 并不支持聚簇索引。
+   由于数据物理存储排序方式只能有一种，所以**每个Mysql 的表只能有一个聚簇索引**。一般情况下就是该表的主键。
+   为了充分利用聚簇索引的聚簇的特性，所以innodb **表的主键列尽量选用有序的顺序id**(如AUTO_INCREMENT自增列) 而不建议用无序的id，比如uuid 这种。

>   【InnoDB和MyISAM存储引擎】
>
>   **InnoDB存储引擎通过主键聚集数据(聚簇索引)。**如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有唯一索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。
>
>   **MyISAM中主键索引和其他索引 都指向物理行 (非聚簇索引)**

---

## 4. MySQL索引分类

**1. 索引的分类**

| 索引种类 | 含义                           |
| ---- | ---------------------------- |
| 单值索引 | 即一个索引只包含单个列，一个表可以有多个单列索引     |
| 唯一索引 | 索引列的值必须唯一，但允许有空值             |
| 主键索引 | 设定为主键后数据库会自动建立索引，innodb为聚簇索引 |
| 复合索引 | 即一个索引包含多个列                   |

**2. 语法**

~~~mysql
CREATE TABLE customer (
  id INT(10) UNSIGNED AUTO_INCREMENT ,
  customer_no VARCHAR(200),
  customer_name VARCHAR(200),
  
  PRIMARY KEY(id),	#设定主键，自动建立主键索引
  KEY (customer_name),	#单值索引
  UNIQUE (customer_no),	#唯一索引
  KEY (customer_no,customer_name)	#复合索引
);
~~~

单独建单值索引：CREATE INDEX idx_customer_name ON customer(customer_name);

单独建唯一索引：CREATE UNIQUE INDEX idx_customer_no ON customer(customer_no);

单独建复合索引：CREATE INDEX idx_no_name ON customer(customer_no,customer_name);

---

## 5. 索引创建的时机

### 5.1 适合创建索引的情况

+   主键自动建立唯一索引；
+    频繁作为查询条件的字段应该创建索引
+    查询中与其它表关联的字段，外键关系建立索引
+    单键/组合索引的选择问题， 组合索引性价比更高
+    查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
+    查询中统计或者分组字段



### 5.2 不适合创建索引的情况

+   表记录太少
+    经常增删改的表或者字段
+   Where 条件里用不到的字段不创建索引
+   过滤性不好的不适合建索引