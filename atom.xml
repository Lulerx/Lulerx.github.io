<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Luler</title>
  
  <subtitle>及时行乐</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-20T01:52:13.836Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Luler</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常见面试题</title>
    <link href="http://yoursite.com/2020/08/20/%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2020/08/20/%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%A2%98/</id>
    <published>2020-08-20T01:47:38.893Z</published>
    <updated>2020-08-20T01:52:13.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js中const，var，let区别与用法"><a href="#js中const，var，let区别与用法" class="headerlink" title="js中const，var，let区别与用法"></a>js中const，var，let区别与用法</h3><p>1.const定义的变量不可以修改，而且必须初始化。</p><p>2.var定义的变量可以修改，如果不初始化会输出undefined，不会报错。</p><p>3.let是块级作用域，函数内部使用let定义后，对函数外部无影响。</p><h3 id="trim函数"><a href="#trim函数" class="headerlink" title="trim函数"></a><strong>trim函数</strong></h3><p>trim()删除文本中除单词间的单个空格之外的所有空格</p><h3 id="window-confirm"><a href="#window-confirm" class="headerlink" title="window.confirm()"></a>window.confirm()</h3><p>window.confirm()方法用于显示一个带有指定消息和确认及取消按钮的对话框。</p><p>如果访问者点击”确定”，此方法返回true，否则返回false。</p><h3 id="js的unshift-方法"><a href="#js的unshift-方法" class="headerlink" title="js的unshift() 方法"></a>js的unshift() 方法</h3><p>unshift() 可向数组的开头添加一个或更多元素，并返回新的长度。</p><p><strong>String、StringBuffer、StringBuilder的区别</strong></p><p>String是由final修饰，一旦被创建便不可更改，而StringBuilder和StringBuffer是可变的。</p><p>对于StringBuffer和StringBuilder来说区别不大，StringBuffer在方法上用synchronized修饰，是线程安全的，而StringBuilder是线程不安全的。</p><p><strong>HashMap的实现原理？什么场景下使用HashMap、LinkedHashMap、ConcurrentHashMap、WeakHashMap?哪些是线程安全的？</strong></p><p>hashMap的存储结构是由数组加链表/红黑树组成，采用Entry数组来存储key-value对，Entry类又是链表结构。根据key值通过哈希算法获取哈希值确定数组存储的位置，同一个哈希值下挂着链表，当链表的数量超过8时，链表转换成红黑树存储。</p><p>HashMap是以键值形式对存储对象，线程不安全且无序。在对顺序没有要求且单线程下使用。</p><p>LinkedHashMap的键值有序，但线程不安全。在单线程下对顺序有要求的场景使用。</p><p>ConcurrentHashMap是线程安全的Map，在多线程环境下使用。</p><p>WeakHashMap是线程不安全的，是基于弱引用，其对象可能随时被回收，适用于缓存的场景。</p><p><strong>synchronized和lock锁机制的异同</strong></p><p>异：</p><ol><li>synchronized可以加在方法上，也可以加在特定代码块上；lock需要显示地指定起始位置和终止位置。</li><li>synchronized是由JVM执行的；而lock的锁定是通过代码实现的，他有比synchronized更精确的线程语义和更好的性能。</li><li>synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，而且是自动解锁。而lock则需要开发人员手动释放锁，并且必须在finally中释放，否则会引起死锁。</li></ol><p>同：</p><p>lock能完成synchronized所实现的所有功能。</p><p><strong>JVM加载Class文件的原理机制？</strong></p><p>双亲委派机制：一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有父类加载器无法加载该类时，才会尝试从自己的类路径中加载该类。所以一个类在进行加载时，总是会先加载超类Object。</p><p><strong>JVM的内存结构及GC的工作原理？</strong></p><p>在JDK8中，JVM被划分成五个区域：堆、方法区、虚拟机栈、本地方法栈、程序计数器。</p><p>GC即为垃圾收集器。JVM中将对象的引用分为了四种类型，不同的对象引用类型GC会采用不同的方法进行回收：<br>（1）强引用：默认情况下，对象采用的均为强引用（GC不会回收）<br>（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）<br>（3）弱引用：在GC时一定会被GC回收<br>（4）虚引用：在GC时一定会被GC回收</p><p><strong>springMVC的实现原理？核心是什么？请求流程怎么处理？控制反转是怎么实现的？</strong></p><p>请求处理流程：</p><ol><li>客户端请求交给前端控制器；</li><li>前端控制器根据请求信息调用处理器映射器；</li><li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器并返回给前端控制器；</li><li>前端控制器调用处理器适配器；</li><li>处理器适配器调用合适的后端控制器 ；</li><li>后端控制器执行完成返回ModelAndView ；</li><li>前端控制器将ModelAndView传给视图解析器，解析后返回view；</li><li>前端控制器进行视图渲染并响应用户；</li></ol><p>五大核心组件：</p><p>　1.DispatcherServlet　　请求入口</p><p>　2.HandlerMapping　　  请求派发,负责请求和控制器建立一一对应的关系</p><p>　3.Controller　　　　　  处理器</p><p>　4.ModelAndView　　　  封装模型信息和视图信息</p><p>　5.ViewResolver　　　　视图处理器,定位页面</p><p>控制反转：</p><p>我们每次使用spring框架都要配置xml文件，这个xml配置了bean的id和class。</p><p>spring中默认的bean为单实例模式，通过bean的class引用反射机制可以创建这个实例。</p><p>因此，spring框架通过反射替我们创建好了实例并且替我们维护他们。</p><p>A需要引用B类，spring框架就会通过xml把B实例的引用传给了A的成员变量。</p><p><strong>从在浏览器地址中输入域名到数据返回发生了什么？</strong></p><ol><li>应用层DNS解析域名</li><li>应用层客户端发送HTTP请求</li><li>传输层TCP传输报文</li><li>网络层IP协议查询MAC地址</li><li>数据到达数据链路层</li><li>服务器接收数据</li><li>服务器处理请求</li><li>服务器返回相应文件</li></ol><p>解释三次握手，四次挥手以及为什么需要三次握手，四次挥手？</p><p>三次握手：</p><ol><li>客户端请求建立连接：SYN=1，seq=x；</li><li>服务器对客户端的请求进行响应：SYN=1，ACK=1，seq=y，ack=x+1；</li><li>客户端对服务器端的响应信息进行回应：ACK=1，seq=x+1，ack=y+1</li></ol><p>四次挥手：</p><ol><li>客户端请求断开连接： FIN=1，seq = u；</li><li>服务端对客户端的请求应答：ACK=1，seq=v，ack=u+1；</li><li>服务端请求断开连接：FIN=1，ACK=1，seq=w，ack=u+1；</li><li>客户端对服务端的请求应答：ACK=1，seq=u+1，ack=w+1</li></ol><p>TCP的核心思想是既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求。</p><p>TCP连接握手，握的是什么？    </p><p>是通信双方数据远点的序列号！</p><p>双方都需要确认对方收到了自己的序列号！</p><p><strong>什么是线程和进程，有什么区别？</strong></p><p>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</p><p>线程是进程的一个实体，是进程的一条执行路径。</p><p>一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间</p><p>主要区别：</p><ol><li>不同进程间数据很难共享，同一进程下不同线程间数据很易共享</li><li>进程要比线程消耗更多的计算机资源</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉</li><li>调度和切换：线程上下文切换比进程上下文切换快得多</li><li>在多线程OS中，进程不是一个可执行的实体</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。－”互斥锁”</li><li>进程使用的内存地址可以限定使用量。－“信号量”</li></ol><p><strong>线程间常用的通信方法？</strong></p><ol><li>使用volatile关键字</li><li>使用Object类的wait() 和 notify() 方法</li><li>使用JUC工具类 CountDownLatch</li><li>使用 ReentrantLock 结合 Condition</li><li>基本LockSupport实现线程间的阻塞和唤醒</li></ol><p><strong>JDBC使用步骤</strong></p><ol><li>加载数据库驱动</li><li>通过DriverManager获取数据库连接</li><li>通过Connection对象创建Statement对象</li><li>使用Statement执行SQL语句</li><li>操作ResultSet结果集</li><li>回收数据库资源，包括关闭ResultSet、Statement和Connection等资源</li></ol><p><strong>JDBC的Statement、PerparStatement、CallableStatement的区别？</strong></p><p>Statement只允许执行写死的SQL语句；</p><p>PerparStatement可以允许执行带占位符的SQL语句，能有效防止SQL注入；</p><p>CallableStatement是用于调用存储过程；</p><p><strong>数据库隔离级别？各自含义？mysql的默认隔离级别？</strong></p><ol><li>Read Uncommit (读未提交)        脏读，不可重复读，幻读都不能避免</li><li>Read commit (读已提交)                能避免脏读，不能避免不可重复读，幻读</li><li>Repeatable Read (可重复读)          能避免脏读，不可重复读，不能避免幻读</li><li>Serialzable (可串行化)                     能避免脏读，不可重复读，幻读</li></ol><p>MySQL默认的存储引擎InnoDB默认的隔离级别为Repeatable Read (可重复读 )，而且InnoDB实现的Repeatable Read避免了幻读。</p><p><strong>数据库索引的实现原理？什么情况下索引会失效？</strong></p><p>索引是使用B+树实现的数据结构。索引的思想就是，根据表中的某个属性建立一套算法，每次查询的时候，在内存中根据该算法得到出所需要的数据的物理地址，根据物理地址直接去磁盘中拿到结果数据，不用将表中的所有数据都加载到内存扫描一遍。这有点类似于，我们查字典的时候，根据偏旁部首等信息对一个汉字进行页码定位（这个过程可以看做是索引的算法执行的过程），查到一个汉字的页码，根据该页码直接找到汉字所在的页，不需要把整个字典翻一遍。</p><p>索引失效的情况：</p><ol><li>如果条件中有or，即使其中有条件带索引也不会使用；</li><li>.对于多列索引，不是使用的第一部分，则不会使用索引；</li><li>like查询是以%开头，索引会失效；</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li></ol><p><strong>对java8中Stream API的理解？</strong></p><p>Stream 流是Java8中处理集合的关键抽象概念，它可以对集合进行非常复杂的查找、过滤、筛选等操作，在新版的JPA中，也已经加入了Stream。</p><p>Stream API的特点：</p><ol><li>Stream API的使用和同样是java8新特性的lambda表达式密不可分，可以大大提高编码效率和代码可读性。</li><li>Stream API提供串行和并行两种操作，其中并行操作能发挥多核处理器的优势，使用fork/join的方式进行并行操作以提高运行速度。</li><li>Stream API进行并行操作无需编写多线程代码即可写出高效的并发程序，且通常可避免多线程代码出错的问题。</li></ol><p><strong>java8中函数式接口的用途是什么？</strong></p><p>函数式接口也叫功能性接口，用来特指某类型接口，为Java 中Lambda的实现而定义。在lambda的实现过程中，java选择接口作为Lambda表达式的目标类型，有函数式接口就可以接受Lambda表达式作为函数式接口的实现，更多是为了简化代码。</p><p><strong>Stream流中间操作之map和flatMap的区别？</strong></p><p>从源码上看出：</p><p>map函数式接口抽象方法的返回值是R，flatMap函数式接口抽象方法返回值是Stream&lt; R &gt;</p><p>所以flatMap作用就是将返回的Stream&lt; R &gt;拆开，再组合每个值成新的Stream&lt; R &gt;，</p><p>即map只是一维 1对1 的映射，而flatmap可以将一个2维的集合映射成一个一维,相当于他映射的深度比map深了一层 </p><p><strong>常见的数据结构？常见的算法？</strong></p><p>线性表，链表，队列，栈，二叉树，图</p><p>递归算法，常见排序算法，分治法，贪心算法，动态规划算法</p><p>冒泡排序</p><p>交换排序</p><p>快速排序</p><p>希尔排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;js中const，var，let区别与用法&quot;&gt;&lt;a href=&quot;#js中const，var，let区别与用法&quot; class=&quot;headerlink&quot; title=&quot;js中const，var，let区别与用法&quot;&gt;&lt;/a&gt;js中const，var，let区别与用法&lt;/</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>mysql笔记</title>
    <link href="http://yoursite.com/2020/08/19/mysql%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/08/19/mysql%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-19T05:50:41.419Z</published>
    <updated>2020-08-19T09:38:33.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mysql笔记"><a href="#mysql笔记" class="headerlink" title="mysql笔记"></a>mysql笔记</h1><h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><p>数值类型</p><table><thead><tr><th>类型</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>tinyint</td><td>-128~127</td><td>0~255</td></tr><tr><td>int</td><td>-2^31 ~ 2^31-1</td><td>0~2^32-1</td></tr></tbody></table><p>浮点型</p><table><thead><tr><th>类型</th><th>大小</th></tr></thead><tbody><tr><td>float</td><td>4字节</td></tr><tr><td>double</td><td>8字节</td></tr></tbody></table><p>时间日期</p><table><thead><tr><th>类型</th><th>格式</th></tr></thead><tbody><tr><td>Datetime</td><td>YYYY-mm-dd HH:MMss</td></tr><tr><td>Date</td><td>YYYY-mm-dd</td></tr><tr><td>Time</td><td>HH:MM:ss</td></tr><tr><td>Timestamp</td><td>时间戳，从1970/1/1开始，格式与Datetime一致</td></tr></tbody></table><p>字符串型</p><table><thead><tr><th>格式</th><th>长度</th></tr></thead><tbody><tr><td>char</td><td>最大长度255</td></tr><tr><td>varchar</td><td>可变字符串，最大长度65536</td></tr><tr><td>Text</td><td>通常超过255就会使用</td></tr></tbody></table><hr><h2 id="数据库语法"><a href="#数据库语法" class="headerlink" title="数据库语法"></a>数据库语法</h2><p><strong>查询已有数据库列表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p><strong>创建数据库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库库名 [选项];</span><br></pre></td></tr></table></figure><p><strong>查看建库语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create database 数据库名;</span><br></pre></td></tr></table></figure><p><strong>修改数据库(数据库名不可更改)：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database 数据库名 [选项];</span><br></pre></td></tr></table></figure><p><strong>删除数据库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database [if exists] 数据库名;</span><br></pre></td></tr></table></figure><p><strong>进入/使用数据库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><h2 id="数据库约束"><a href="#数据库约束" class="headerlink" title="数据库约束"></a>数据库约束</h2><table><thead><tr><th>约束类型</th><th>语法</th><th>举例</th></tr></thead><tbody><tr><td>非空约束</td><td>not null</td><td></td></tr><tr><td>唯一约束</td><td>unique</td><td></td></tr><tr><td>主键约束</td><td>primary kry</td><td></td></tr><tr><td>条件约束</td><td>check</td><td>$ check(id&gt;0)</td></tr><tr><td>默认值</td><td>default</td><td>$ default ‘ ‘</td></tr><tr><td>自增约束</td><td>auto_increment</td><td></td></tr></tbody></table><blockquote><p>表级约束：</p><p>字符集：charser/ character set        具体字符集</p><p>校对集：collate    具体校对集</p><p>存储引擎：engine        具体存储引擎（InnoDB   MyISAM）</p></blockquote><hr><h2 id="表语法"><a href="#表语法" class="headerlink" title="表语法"></a>表语法</h2><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">      name char(32) default &#39;&#39;,</span><br><span class="line">      age int</span><br><span class="line">)engine&#x3D;InnoDB charset&#x3D;utf8</span><br></pre></td></tr></table></figure><p><strong>查看所有表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><p><strong>查询带关键字的表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables like &#39;%关键字%&#39;;</span><br></pre></td></tr></table></figure><p><strong>查看建表语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure><p><strong>查看表结构：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#三种方式:</span><br><span class="line">desc 表名;</span><br><span class="line">describe 表名;</span><br><span class="line">show columns from 表名;</span><br></pre></td></tr></table></figure><p><strong>删除表（可多表删除）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table [if exists] 表名1，表名2...;</span><br></pre></td></tr></table></figure><p><strong>修改表名：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename table 旧表名 to 新表名;</span><br></pre></td></tr></table></figure><p><strong>修改表选项（字符集，校对集，存储引擎）:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 表选项&#x3D;值;</span><br></pre></td></tr></table></figure><p><strong>新增表字段：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 字段名 数据类型 [列属性] [位置];</span><br></pre></td></tr></table></figure><p><strong>修改表字段：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change 旧字段 新字段名 数据类型 [列属性] [位置];</span><br></pre></td></tr></table></figure><p><strong>删除字段：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure><hr><h2 id="表数据操作（增删改查）"><a href="#表数据操作（增删改查）" class="headerlink" title="表数据操作（增删改查）"></a>表数据操作（增删改查）</h2><p><strong>插入数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(字段列表) values(对应字段值列表1),(对应字段值列表2)...</span><br></pre></td></tr></table></figure><p><strong>删除数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 [where 条件];</span><br></pre></td></tr></table></figure><p><strong>更新数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段&#x3D;值 [where 条件];</span><br></pre></td></tr></table></figure><p><strong>查询数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *&#x2F;字段列表 from 表名 [where 条件];</span><br></pre></td></tr></table></figure><hr><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><h3 id="where条件查询"><a href="#where条件查询" class="headerlink" title="where条件查询"></a><strong>where条件查询</strong></h3><p>where的字符串查询不区分大小写，若要区分则用<strong>binary</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where binary name &#x3D; &#39;zhangsan&#39;;</span><br></pre></td></tr></table></figure><h3 id="like模糊查询"><a href="#like模糊查询" class="headerlink" title="like模糊查询"></a><strong>like模糊查询</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where name like &#39;zhang%&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>占位符：</p><p>​    % : 匹配0个或多个字符</p><p>​    _ : 匹配1个字符</p></blockquote><h3 id="order-by-排序"><a href="#order-by-排序" class="headerlink" title="order by 排序"></a><strong>order by 排序</strong></h3><p>默认为升序 ASC，倒序使用 DESC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user order by name desc;</span><br><span class="line">select * from t_user order by age desc name ASC;</span><br></pre></td></tr></table></figure><blockquote><p>使用多个字段排序时，按先后顺序</p><p>按第一字段规则排序时，有重复的数据，再根据第二字段规则排序，以此类推。</p><p>且多个字段时，要显式引用ASC/DESC，否则为默认ASC</p></blockquote><h3 id="in-包含"><a href="#in-包含" class="headerlink" title="in 包含"></a>in 包含</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where id in(1,3,5);</span><br></pre></td></tr></table></figure><h3 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询id在1到5之间的记录（包含1，包含5）</span><br><span class="line">select * from t_user where id between 1 and 5;</span><br></pre></td></tr></table></figure><h3 id="limit-分页"><a href="#limit-分页" class="headerlink" title="limit 分页"></a>limit 分页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询6~15行数据</span><br><span class="line">select * from t_user limit 5 10;</span><br></pre></td></tr></table></figure><h3 id="distinct-去除重复"><a href="#distinct-去除重复" class="headerlink" title="distinct 去除重复"></a><strong>distinct 去除重复</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct * from t_user;</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>AVG</td><td>返回平均值</td></tr><tr><td>count</td><td>返回总记录条数</td></tr><tr><td>sum</td><td>返回数值总和</td></tr><tr><td>min</td><td>返回最小值</td></tr><tr><td>max</td><td>返回最大值</td></tr></tbody></table><blockquote><p>聚合函数无法与where 一起使用</p></blockquote><h3 id="group-by-分组函数"><a href="#group-by-分组函数" class="headerlink" title="group by 分组函数"></a>group by 分组函数</h3><p>分组函数是根据一个或多个字段的唯一组合结果集进行分组</p><p>通常结合<strong>聚合函数</strong>一起使用</p><img src="/images/table1.jpg"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#统计男女人数</span><br><span class="line">select sex as &#39;性别&#39;,count(sex)as &#39;人数&#39; </span><br><span class="line">from t_user </span><br><span class="line">group by sex;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/group1.jpg" alt="group1"></p><blockquote><p>根据性别的唯一组合进行分组，分成 男 女 两组，再结合count()函数进行统计</p></blockquote><p><strong>对字段分组：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#统计不同年龄的男女人数</span><br><span class="line">select sex as &#39;性别&#39;,age as &#39;年龄&#39;,count(sex)as &#39;人数&#39; </span><br><span class="line">from t_user </span><br><span class="line">group by sex,age;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/group2.png" alt="group2"></p><blockquote><p>根据sex, age两个字段进行分组，根据不同值进行唯一组合，再结合聚合函数进行统计</p></blockquote><h3 id="having-条件"><a href="#having-条件" class="headerlink" title="having 条件"></a>having 条件</h3><p>因为聚合不能与where一起使用，所以有了having</p><p>having是用于分组后返回满足条件的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#统计不同年龄的男女人数,并要求年龄不小于19</span><br><span class="line">select sex as &#39;性别&#39;,age as &#39;年龄&#39;,count(sex)as &#39;人数&#39; </span><br><span class="line">from t_user </span><br><span class="line">group by sex,age having age&gt;&#x3D;19;</span><br></pre></td></tr></table></figure><p><img src="/images/having1.jpg" alt="having1"></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p><strong>内连接 inner join</strong></p><p><img src="/images/inner2.png" alt="inner2"></p><p><strong>左外连接 left join</strong></p><p><img src="/images/left_join.png" alt="left_join"></p><p><strong>右外连接 right join</strong></p><p><img src="/images/right_join.png" alt="right_join"></p><p>以员工表和部门表为例，dept代表该员工所在的部门：</p><p>t_employee表</p><p><img src="/images/inner1.png" alt="inner1"></p><p>t_dept表</p><p><img src="/images/t_dept.png" alt="t_dept"></p><p>内连接查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询出员工姓名以及其对应的部门名称</span><br><span class="line">select </span><br><span class="line">e.empName,d.deptName</span><br><span class="line">from t_employee e</span><br><span class="line">INNER JOIN t_dept d</span><br><span class="line">ON e.dept &#x3D; d.id;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/inner3.png" alt="inner3"></p><p>在内连接中赵七没有被查出来，因为他没有对应的部门，现在想要把赵七也查出来，就要使用<strong>左外连接查询</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询所有员工姓名以及他所在的部门名称</span><br><span class="line">select e.empName,d.deptName</span><br><span class="line">from t_employee e</span><br><span class="line">left join t_dept d </span><br><span class="line">on d.id &#x3D; e.dept;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/left2.png" alt="left2"></p><p><strong>右外连接查询</strong>与做查询同理，只是基准表的位置发生了变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.empName,d.deptName</span><br><span class="line">from t_employee e</span><br><span class="line">right join t_dept d </span><br><span class="line">on d.id &#x3D; e.dept;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/right2.png" alt="right2"></p><blockquote><p>总结：</p><p>左连接查询时，左表数据全部显示，若右表没有对应数据，则显示为null；</p><p>右连接查询时，右表数据全部显示，若左表没有对应数据，则显示为null；</p></blockquote><p><strong>自连接查询</strong></p><p>自连接查询就是当前表与自身的连接查询，关键点在于虚拟化出一张表给一个别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询员工以及他的上司的名称，由于上司也是员工，所以这里虚拟化出一张上司表</span><br><span class="line">SELECT e.empName,b.empName</span><br><span class="line">from t_employee e</span><br><span class="line">LEFT JOIN t_employee b</span><br><span class="line">ON e.bossId &#x3D; b.id;</span><br></pre></td></tr></table></figure><p>结果：</p><p><img src="/images/self1.png" alt="self1"></p><p><strong>全外连接 union</strong></p><blockquote><p>mysql是没有全外连接的(mysql中没有full outer join关键字)，想要达到全外连接的效果，可以使用union关键字连接左外连接和右外连接</p></blockquote><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>视图就是一张数据库表，根据表或者视图为基准创建视图。视图本身不存储任何数据，只是将结果集组合在一起。</strong></p><p><strong>视图的优点：</strong></p><ol><li>提高重用性，简化复杂查询。将复杂的查询结果创建成视图，以后直接查询视图</li><li>对数据表进行重构，却不影响程序运行。因为某需求将表拆分后，可通过视图将拆分的表结果结合在一起，而不用去更改后端代码。</li><li>提高了安全性能。可以根据不同的用户权限，设定不同的视图显示。</li><li>让数据更清晰。想要什么样的数据，就创建什么样的视图。</li></ol><p><strong>缺点：</strong></p><ol><li>性能相对较差。查询数据相对慢一些，特别是当视图基于其他视图创建的。</li><li>表依赖关系。当表结构更改时，就必须要更改视图。</li></ol><h3 id="视图语法"><a href="#视图语法" class="headerlink" title="视图语法"></a>视图语法</h3><blockquote><p>视图名一般以“v_”开头，便于区分数据库表</p></blockquote><p><strong>创建视图：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名(字段1，字段2...)</span><br><span class="line">AS select 字段1，字段2...</span><br><span class="line">from ...(表查询语句)</span><br></pre></td></tr></table></figure><p><strong>修改视图：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create or replace view 视图名(字段1，字段2...)</span><br><span class="line">AS select 字段1，字段2...</span><br><span class="line">from ...(表查询语句)</span><br></pre></td></tr></table></figure><blockquote><p>视图创建后就相当于一张数据库表，可用表的语法对其进行修改操作</p></blockquote><blockquote><p>注意：更改视图的数据，基表的数据也会随之改变</p></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p><strong>排好序的快速查找数据结构</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;mysql笔记&quot;&gt;&lt;a href=&quot;#mysql笔记&quot; class=&quot;headerlink&quot; title=&quot;mysql笔记&quot;&gt;&lt;/a&gt;mysql笔记&lt;/h1&gt;&lt;h2 id=&quot;常用数据类型&quot;&gt;&lt;a href=&quot;#常用数据类型&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="联系" scheme="http://yoursite.com/tags/%E8%81%94%E7%B3%BB/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/08/18/hello-world/"/>
    <id>http://yoursite.com/2020/08/18/hello-world/</id>
    <published>2020-08-18T07:57:18.128Z</published>
    <updated>2020-08-19T09:28:19.227Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="联系" scheme="http://yoursite.com/tags/%E8%81%94%E7%B3%BB/"/>
    
  </entry>
  
</feed>
