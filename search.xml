<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络--运输层</title>
      <link href="2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/"/>
      <url>2021/03/13/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络–运输层"><a href="#计算机网络–运输层" class="headerlink" title="计算机网络–运输层"></a>计算机网络–运输层</h2><p>首先我们要知道，网络层是为主机之间提供逻辑通信，而运输层是为应用进程之间提供逻辑通信。</p><h3 id="1-两个主要协议"><a href="#1-两个主要协议" class="headerlink" title="1. 两个主要协议"></a>1. 两个主要协议</h3><ul><li><strong>传输控制协议TCP (Transmission Control Protocol)</strong> —- 提供面 向连接的、可靠的数据传输服务，其数据传输的单位是报文段(segment)。</li><li><strong>用户数据报协议UDP (User Datagram Protocol)</strong> —- 提 供无连接的、尽最大努力(best-effrt)的数据传输服务(不保证数据传输的可靠性)，其数据传输的单位是用户数据报。</li></ul><h3 id="1-1-TCP和UDP的优缺点"><a href="#1-1-TCP和UDP的优缺点" class="headerlink" title="1.1 TCP和UDP的优缺点"></a>1.1 TCP和UDP的优缺点</h3><p>TCP 的优点：可靠、稳定。</p><p>TCP 的缺点：慢，效率低，占用系统资源高</p><p>TCP 的使用场所： 浏览器，用的HTTP FlashFXP，用的FTP Outlook，用的POP、SMTP Putty，用的Telnet、SSH QQ文件传输 ……</p><hr><p>UDP 的优点：快，比TCP稍安全。</p><p>UDP 的缺点：不可靠，不稳定，在数据传递时可能会丢包。</p><p>UDP 的使用场所： QQ语音 QQ视频 TFTP ……</p><h3 id="1-2-TCP和UDP的区别"><a href="#1-2-TCP和UDP的区别" class="headerlink" title="1.2 TCP和UDP的区别"></a>1.2 TCP和UDP的区别</h3><ol><li>TCP 传送数据需要先建立连接，UDP 是无连接的。</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的</li><li>UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li></ol><h3 id="2-三次握手和四次挥手"><a href="#2-三次握手和四次挥手" class="headerlink" title="2. 三次握手和四次挥手"></a>2. 三次握手和四次挥手</h3><p><img src="https://img2020.cnblogs.com/blog/1506061/202103/1506061-20210313164705681-1878190535.png" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202103/1506061-20210313164705681-1878190535.png" srcset="data:image/png;base64,666"></p><p>SYN：表示建立连接标志，发起建立连接请求时，其值为 1，即 SYN = 1</p><p>seq：表示报文序列，连续 报文 seq 值也会连续</p><p>ACK：表示确认标志，ACK = 1 即表示收到报文</p><p>ack：表示确认编号，其值为接受报文的 seq + 1</p><p>FIN：表示断开连接标志，发起断开连接请求时，其值为 1，即 FIN = 1</p><p>具体步骤：</p><p> <strong>三次握手</strong></p><p>（1）第一次握手：客户端向服务端发起。发送数据包SYN=1,seq=1(随机序号)，此时客户端的主动发起使得其状态由原先的CLOSED（关闭）状态进入SYN-SENT（同步已发送）状态<br>（2）第二次握手：服务端向客户端发起。在接收请求前服务端一直处于LISTEN（监听）状态，接收请求后，发送数据包SYN=1,ACK=1,ack=i+1,seq=j(随机值)往客户端，其由原先的LISTEN进入SYN-RCVD（同步收到）状态<br>（3）第三次握手：客户端向服务端发起。客户端收到后检查确认ack，ACK值，正确后则发送数据包ACK=1,ack=j+1。当服务端确认后，则连接建立成功，此时客户端和服务端都进入ESTABLISHED（已建立连接）状态</p><p><strong>四次挥手</strong></p><p>（1）第一次挥手：客户端向服务端发起。发送数据包FIN=1,ACK=1,seq=k（随机值），此时客户端进入FIN-WAIT-1（终止等待1）状态<br>（2）第二次挥手：服务端向客户端发起。发送数据包ACK=1,seq=u（随机值）,ack=k+1,此时服务端进入CLOSE-WAIT(等待关闭)状态，客户端接收并确认ack值后进入FIN-WAIT-2（终止等待2）状态<br>（3）第三次挥手：服务端向客户端发起。在确认数据接收完毕后，用来发起关闭服务端向客户端的数据传送，发送数据包FIN=1，ACK=1,seq=v（随机值）,ack=k+1，此时服务端进入LAST-ACK（最后确认）状态<br>（4）第四次挥手：客户端向服务端发起。在检验服务端发送的数据后，发送数据包ACK=1,seq=k+1,ack=v+1，此时客户端进入TIME-WAIT（时间等待）状态，此时TCP连接还未释放，必须经过2*MSL（最长报文段寿命/最长分节声明其，MSL阿是任何IP数据报能够在因特网中存活的最长时间，任何TCP实现都必须为MSL设定一个值。RFC1122[Braden 1989]的建议值为2分钟，不过院子Berkelcy的实现传统上改用30秒。这意味着TIME-WAIT状态的等待持续时间在1-4分钟之间）时间后，当主动发起关闭端（客户端）撤销相应的TCB后，才进入关闭状态。服务端在接收来自客户端的值后也进入了关闭状态。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础语法</title>
      <link href="2021/02/20/mysql%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/20/mysql%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql基础"><a href="#mysql基础" class="headerlink" title="mysql基础"></a>mysql基础</h1><h2 id="三大范式"><a href="#三大范式" class="headerlink" title="三大范式"></a>三大范式</h2><p><strong>第一范式（1NF）：要求数据库表的每一列都是不可分割的原子数据项。</strong></p><p><strong>第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）</strong></p><blockquote><p>  第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</p></blockquote><p><strong>第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</strong></p><blockquote><p>  第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。</p></blockquote><h2 id="常用数据类型"><a href="#常用数据类型" class="headerlink" title="常用数据类型"></a>常用数据类型</h2><p>数值类型</p><table><thead><tr><th>类型</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>tinyint</td><td>-128~127</td><td>0~255</td></tr><tr><td>int</td><td>-2^31 ~ 2^31-1</td><td>0~2^32-1</td></tr></tbody></table><p>浮点型</p><table><thead><tr><th>类型</th><th>大小</th></tr></thead><tbody><tr><td>float</td><td>4字节</td></tr><tr><td>double</td><td>8字节</td></tr></tbody></table><p>时间日期</p><table><thead><tr><th>类型</th><th>格式</th></tr></thead><tbody><tr><td>Datetime</td><td>YYYY-mm-dd HH:MMss</td></tr><tr><td>Date</td><td>YYYY-mm-dd</td></tr><tr><td>Time</td><td>HH:MM:ss</td></tr><tr><td>Timestamp</td><td>时间戳，从1970/1/1开始，格式与Datetime一致</td></tr></tbody></table><p>字符串型</p><table><thead><tr><th>格式</th><th>长度</th></tr></thead><tbody><tr><td>char</td><td>最大长度255</td></tr><tr><td>varchar</td><td>可变字符串，最大长度65536</td></tr><tr><td>Text</td><td>通常超过255就会使用</td></tr></tbody></table><hr><h2 id="数据库语法"><a href="#数据库语法" class="headerlink" title="数据库语法"></a>数据库语法</h2><p><strong>查询已有数据库列表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show databases;</span><br></pre></td></tr></table></figure><p><strong>创建数据库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database 数据库库名 [选项];</span><br></pre></td></tr></table></figure><p><strong>查看建库语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create database 数据库名;</span><br></pre></td></tr></table></figure><p><strong>修改数据库(数据库名不可更改)：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter database 数据库名 [选项];</span><br></pre></td></tr></table></figure><p><strong>删除数据库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop database [if exists] 数据库名;</span><br></pre></td></tr></table></figure><p><strong>进入/使用数据库：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名;</span><br></pre></td></tr></table></figure><h2 id="数据库约束"><a href="#数据库约束" class="headerlink" title="数据库约束"></a>数据库约束</h2><table><thead><tr><th>约束类型</th><th>语法</th><th>举例</th></tr></thead><tbody><tr><td>非空约束</td><td>not null</td><td></td></tr><tr><td>唯一约束</td><td>unique</td><td></td></tr><tr><td>主键约束</td><td>primary kry</td><td></td></tr><tr><td>条件约束</td><td>check</td><td>$ check(id&gt;0)</td></tr><tr><td>默认值</td><td>default</td><td>$ default ‘ ‘</td></tr><tr><td>自增约束</td><td>auto_increment</td><td></td></tr></tbody></table><blockquote><p>表级约束：</p><p>字符集：charser/ character set        具体字符集</p><p>校对集：collate    具体校对集</p><p>存储引擎：engine        具体存储引擎（InnoDB   MyISAM）</p></blockquote><hr><h2 id="表语法"><a href="#表语法" class="headerlink" title="表语法"></a>表语法</h2><p><strong>例子：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create table t_user(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">      name char(32) default &#39;&#39;,</span><br><span class="line">      age int</span><br><span class="line">)engine&#x3D;InnoDB charset&#x3D;utf8</span><br></pre></td></tr></table></figure><p><strong>查看所有表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><p><strong>查询带关键字的表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables like &#39;%关键字%&#39;;</span><br></pre></td></tr></table></figure><p><strong>查看建表语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create table 表名;</span><br></pre></td></tr></table></figure><p><strong>查看表结构：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#三种方式:</span><br><span class="line">desc 表名;</span><br><span class="line">describe 表名;</span><br><span class="line">show columns from 表名;</span><br></pre></td></tr></table></figure><p><strong>删除表（可多表删除）：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table [if exists] 表名1，表名2...;</span><br></pre></td></tr></table></figure><p><strong>修改表名：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename table 旧表名 to 新表名;</span><br></pre></td></tr></table></figure><p><strong>修改表选项（字符集，校对集，存储引擎）:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 表选项&#x3D;值;</span><br></pre></td></tr></table></figure><p><strong>新增表字段：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 字段名 数据类型 [列属性] [位置];</span><br></pre></td></tr></table></figure><p><strong>修改表字段：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change 旧字段 新字段名 数据类型 [列属性] [位置];</span><br></pre></td></tr></table></figure><p><strong>删除字段：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br></pre></td></tr></table></figure><hr><h2 id="表数据操作（增删改查）"><a href="#表数据操作（增删改查）" class="headerlink" title="表数据操作（增删改查）"></a>表数据操作（增删改查）</h2><p><strong>插入数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名(字段列表) values(对应字段值列表1),(对应字段值列表2)...</span><br></pre></td></tr></table></figure><p><strong>删除数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 [where 条件];</span><br></pre></td></tr></table></figure><p><strong>更新数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段&#x3D;值 [where 条件];</span><br></pre></td></tr></table></figure><p><strong>查询数据：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select *&#x2F;字段列表 from 表名 [where 条件];</span><br></pre></td></tr></table></figure><hr><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><h3 id="where条件查询"><a href="#where条件查询" class="headerlink" title="where条件查询"></a><strong>where条件查询</strong></h3><p>where的字符串查询不区分大小写，若要区分则用<strong>binary</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where binary name &#x3D; &#39;zhangsan&#39;;</span><br></pre></td></tr></table></figure><h3 id="like模糊查询"><a href="#like模糊查询" class="headerlink" title="like模糊查询"></a><strong>like模糊查询</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where name like &#39;zhang%&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>占位符：</p><p>​    % : 匹配0个或多个字符</p><p>​    _ : 匹配1个字符</p></blockquote><h3 id="order-by-排序"><a href="#order-by-排序" class="headerlink" title="order by 排序"></a><strong>order by 排序</strong></h3><p>默认为升序 ASC，倒序使用 DESC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user order by name desc;</span><br><span class="line">select * from t_user order by age desc name ASC;</span><br></pre></td></tr></table></figure><blockquote><p>使用多个字段排序时，按先后顺序</p><p>按第一字段规则排序时，有重复的数据，再根据第二字段规则排序，以此类推。</p><p>且多个字段时，要显式引用ASC/DESC，否则为默认ASC</p></blockquote><h3 id="in-包含"><a href="#in-包含" class="headerlink" title="in 包含"></a>in 包含</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t_user where id in(1,3,5);</span><br></pre></td></tr></table></figure><h3 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询id在1到5之间的记录（包含1，包含5）</span><br><span class="line">select * from t_user where id between 1 and 5;</span><br></pre></td></tr></table></figure><h3 id="limit-分页"><a href="#limit-分页" class="headerlink" title="limit 分页"></a>limit 分页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#查询6~15行数据</span><br><span class="line">select * from t_user limit 5 10;</span><br></pre></td></tr></table></figure><h3 id="distinct-去除重复"><a href="#distinct-去除重复" class="headerlink" title="distinct 去除重复"></a><strong>distinct 去除重复</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select distinct * from t_user;</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><table><thead><tr><th>函数名</th><th>作用</th></tr></thead><tbody><tr><td>AVG</td><td>返回平均值</td></tr><tr><td>count</td><td>返回总记录条数</td></tr><tr><td>sum</td><td>返回数值总和</td></tr><tr><td>min</td><td>返回最小值</td></tr><tr><td>max</td><td>返回最大值</td></tr></tbody></table><blockquote><p>聚合函数无法与where 一起使用</p></blockquote><h3 id="group-by-分组函数"><a href="#group-by-分组函数" class="headerlink" title="group by 分组函数"></a>group by 分组函数</h3><p>分组函数是根据一个或多个字段的唯一组合结果集进行分组</p><p>通常结合<strong>聚合函数</strong>一起使用</p><img src="/images/table1.jpg" class="lazyload" data-srcset="/images/table1.jpg" srcset="data:image/png;base64,666"><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#统计男女人数</span><br><span class="line">select sex as &#39;性别&#39;,count(sex)as &#39;人数&#39; </span><br><span class="line">from t_user </span><br><span class="line">group by sex;</span><br></pre></td></tr></table></figure><p>结果：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/group1.jpg" class="lazyload" data-srcset="/images/group1.jpg" srcset="data:image/png;base64,666" alt="group1"/></div><span class="image-caption">group1</span></div><blockquote><p>根据性别的唯一组合进行分组，分成 男 女 两组，再结合count()函数进行统计</p></blockquote><p><strong>对字段分组：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#统计不同年龄的男女人数</span><br><span class="line">select sex as &#39;性别&#39;,age as &#39;年龄&#39;,count(sex)as &#39;人数&#39; </span><br><span class="line">from t_user </span><br><span class="line">group by sex,age;</span><br></pre></td></tr></table></figure><p>结果：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/group2.png" class="lazyload" data-srcset="/images/group2.png" srcset="data:image/png;base64,666" alt="group2"/></div><span class="image-caption">group2</span></div><blockquote><p>根据sex, age两个字段进行分组，根据不同值进行唯一组合，再结合聚合函数进行统计</p></blockquote><h3 id="having-条件"><a href="#having-条件" class="headerlink" title="having 条件"></a>having 条件</h3><p>因为聚合不能与where一起使用，所以有了having</p><p>having是用于分组后返回满足条件的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#统计不同年龄的男女人数,并要求年龄不小于19</span><br><span class="line">select sex as &#39;性别&#39;,age as &#39;年龄&#39;,count(sex)as &#39;人数&#39; </span><br><span class="line">from t_user </span><br><span class="line">group by sex,age having age&gt;&#x3D;19;</span><br></pre></td></tr></table></figure><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/having1.jpg" class="lazyload" data-srcset="/images/having1.jpg" srcset="data:image/png;base64,666" alt="having1"/></div><span class="image-caption">having1</span></div><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p><strong>内连接 inner join</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/inner2.png" class="lazyload" data-srcset="/images/inner2.png" srcset="data:image/png;base64,666" alt="inner2"/></div><span class="image-caption">inner2</span></div><p><strong>左外连接 left join</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/left_join.png" class="lazyload" data-srcset="/images/left_join.png" srcset="data:image/png;base64,666" alt="left_join"/></div><span class="image-caption">left_join</span></div><p><strong>右外连接 right join</strong></p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/right_join.png" class="lazyload" data-srcset="/images/right_join.png" srcset="data:image/png;base64,666" alt="right_join"/></div><span class="image-caption">right_join</span></div><p>以员工表和部门表为例，dept代表该员工所在的部门：</p><p>t_employee表</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/inner1.png" class="lazyload" data-srcset="/images/inner1.png" srcset="data:image/png;base64,666" alt="inner1"/></div><span class="image-caption">inner1</span></div><p>t_dept表</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/t_dept.png" class="lazyload" data-srcset="/images/t_dept.png" srcset="data:image/png;base64,666" alt="t_dept"/></div><span class="image-caption">t_dept</span></div><p>内连接查询：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#查询出员工姓名以及其对应的部门名称</span><br><span class="line">select </span><br><span class="line">e.empName,d.deptName</span><br><span class="line">from t_employee e</span><br><span class="line">INNER JOIN t_dept d</span><br><span class="line">ON e.dept &#x3D; d.id;</span><br></pre></td></tr></table></figure><p>结果：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/inner3.png" class="lazyload" data-srcset="/images/inner3.png" srcset="data:image/png;base64,666" alt="inner3"/></div><span class="image-caption">inner3</span></div><p>在内连接中赵七没有被查出来，因为他没有对应的部门，现在想要把赵七也查出来，就要使用<strong>左外连接查询</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询所有员工姓名以及他所在的部门名称</span><br><span class="line">select e.empName,d.deptName</span><br><span class="line">from t_employee e</span><br><span class="line">left join t_dept d </span><br><span class="line">on d.id &#x3D; e.dept;</span><br></pre></td></tr></table></figure><p>结果：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/left2.png" class="lazyload" data-srcset="/images/left2.png" srcset="data:image/png;base64,666" alt="left2"/></div><span class="image-caption">left2</span></div><p><strong>右外连接查询</strong>与做查询同理，只是基准表的位置发生了变化：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT e.empName,d.deptName</span><br><span class="line">from t_employee e</span><br><span class="line">right join t_dept d </span><br><span class="line">on d.id &#x3D; e.dept;</span><br></pre></td></tr></table></figure><p>结果：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/right2.png" class="lazyload" data-srcset="/images/right2.png" srcset="data:image/png;base64,666" alt="right2"/></div><span class="image-caption">right2</span></div><blockquote><p>总结：</p><p>左连接查询时，左表数据全部显示，若右表没有对应数据，则显示为null；</p><p>右连接查询时，右表数据全部显示，若左表没有对应数据，则显示为null；</p></blockquote><p><strong>自连接查询</strong></p><p>自连接查询就是当前表与自身的连接查询，关键点在于虚拟化出一张表给一个别名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#查询员工以及他的上司的名称，由于上司也是员工，所以这里虚拟化出一张上司表</span><br><span class="line">SELECT e.empName,b.empName</span><br><span class="line">from t_employee e</span><br><span class="line">LEFT JOIN t_employee b</span><br><span class="line">ON e.bossId &#x3D; b.id;</span><br></pre></td></tr></table></figure><p>结果：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/self1.png" class="lazyload" data-srcset="/images/self1.png" srcset="data:image/png;base64,666" alt="self1"/></div><span class="image-caption">self1</span></div><p><strong>全外连接 union</strong></p><blockquote><p>mysql是没有全外连接的(mysql中没有full outer join关键字)，想要达到全外连接的效果，可以使用union关键字连接左外连接和右外连接</p></blockquote><hr><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p><strong>视图就是一张数据库表，根据表或者视图为基准创建视图。视图本身不存储任何数据，只是将结果集组合在一起。</strong></p><p><strong>视图的优点：</strong></p><ol><li>提高重用性，简化复杂查询。将复杂的查询结果创建成视图，以后直接查询视图</li><li>对数据表进行重构，却不影响程序运行。因为某需求将表拆分后，可通过视图将拆分的表结果结合在一起，而不用去更改后端代码。</li><li>提高了安全性能。可以根据不同的用户权限，设定不同的视图显示。</li><li>让数据更清晰。想要什么样的数据，就创建什么样的视图。</li></ol><p><strong>缺点：</strong></p><ol><li>性能相对较差。查询数据相对慢一些，特别是当视图基于其他视图创建的。</li><li>表依赖关系。当表结构更改时，就必须要更改视图。</li></ol><h3 id="视图语法"><a href="#视图语法" class="headerlink" title="视图语法"></a>视图语法</h3><blockquote><p>视图名一般以“v_”开头，便于区分数据库表</p></blockquote><p><strong>创建视图：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create view 视图名(字段1，字段2...)</span><br><span class="line">AS select 字段1，字段2...</span><br><span class="line">from ...(表查询语句)</span><br></pre></td></tr></table></figure><p><strong>修改视图：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create or replace view 视图名(字段1，字段2...)</span><br><span class="line">AS select 字段1，字段2...</span><br><span class="line">from ...(表查询语句)</span><br></pre></td></tr></table></figure><blockquote><p>视图创建后就相当于一张数据库表，可用表的语法对其进行修改操作</p></blockquote><blockquote><p>注意：更改视图的数据，基表的数据也会随之改变</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
          <category> mysql基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="2021/02/20/%E9%94%99%E9%A2%98/"/>
      <url>2021/02/20/%E9%94%99%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<hr><hr><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>局部内部类是放在代码块或方法中的，不能有访问控制修饰符，且不能用static修饰</p><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p>成员方法又称为实例方法</p><p>静态方法又称为类方法</p><p>静态方法中没有this指针</p><h4 id="局部变量没有默认初始值"><a href="#局部变量没有默认初始值" class="headerlink" title="局部变量没有默认初始值"></a>局部变量没有默认初始值</h4><p>类中声明的变量有默认初始值，而局部变量没有默认初始值。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>在JAVA中，假设A有构造方法A(int a)，则在类A的其他构造方法中调用该构造方法和语句格式应该为：this.(x)</p><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p>这条语句一共创建了多少个对象：String s=”welcome”+”to”+360;    ——-&gt;  1个</p><p>字面量的拼接是在编译时完成的，直接放入字符串常量池。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>常见设计模式</title>
      <link href="2021/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
      <url>2021/02/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>设计模式六大原则</p><ol><li><strong>单一职责原则：</strong>一个类只负责一个功能领域中的相应职责</li><li><strong>开闭原则：</strong>一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展</li><li><strong>里氏代换原则：</strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象</li><li><strong>依赖倒置原则：</strong>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：要面向接口编程，不要面向实现编程。</li><li><strong>接口隔离原则：</strong>使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</li><li><strong>迪米特法则：</strong>一个软件实体应当尽可能少地与其他实体发生相互作用</li></ol><p>记录一下几种常用数设计模式。</p><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><h3 id="1-1-定义和特点"><a href="#1-1-定义和特点" class="headerlink" title="1.1 定义和特点"></a>1.1 定义和特点</h3><p>定义：所谓单例，就是整个程序有且仅有一个实例。</p><p>特点：</p><ul><li>类构造器私有</li><li>持有自己类型的属性</li><li>对外提供获取实例的静态方法</li></ul><h3 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h3><p>优点：</p><ol><li>提供了对唯一实例的受控访问；</li><li>节省系统资源。由于系统中内存只存在一个对象，因此可以节约资源的资源，对于一些繁琐的创建和销毁的对象，单例模式无意中可以提高系统的性能；</li><li>单例模式允许可变的数目的实例，使用单利模式进行扩展，使用控制单利对象相似的方法可以获取指定个数的实例，及解决了单利对象共享过多，而有损性能的问题。</li></ol><p>缺点：</p><ol><li>由于单例模式不是抽象的，所有可扩展性比较差。</li><li>单例类，职责过重，在一定程度上违背了单一职责原则</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。</li></ol><h3 id="1-3-饿汉式"><a href="#1-3-饿汉式" class="headerlink" title="1.3 饿汉式"></a>1.3 饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="comment">// 1.在类的内部创建自行实例,持有自己类型的属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      <span class="comment">// 2.将构造函数私有化，不可以通过new的方式来创建对象</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">      <span class="comment">// 3.提供获取唯一实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一上来就创建对象，线程安全，比较常用，但是容易产生垃圾，<strong>因为如果该实例从始至终都没被使用过，则会造成内存浪费</strong></p><h3 id="1-4-懒汉式"><a href="#1-4-懒汉式" class="headerlink" title="1.4 懒汉式"></a>1.4 懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">      <span class="comment">//持有自己类型的属性，先不创建对象，用到时再创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">      <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">      <span class="comment">//对外提供获取实例的静态方法(多线程环境下加锁)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; </span><br><span class="line">          <span class="comment">// 用到时如果这个对象引用为null，我们就创建并返回出去</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程不安全，使用synchronized加锁；但是直接在方法上加锁的方式其实不够好，在多线程环境下性能会比较低，下面是<strong>双重检测机制(DCL)懒汉式</strong></p><h3 id="1-5-双重检测机制-DCL-懒汉式"><a href="#1-5-双重检测机制-DCL-懒汉式" class="headerlink" title="1.5 双重检测机制(DCL)懒汉式"></a>1.5 双重检测机制(DCL)懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  <span class="comment">// volatile实现内存可见性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  <span class="comment">//此处判断是为了提高性能</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  //同步代码块进行线程加锁</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于<code>singleton singleton = new Singleton()</code>对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用<code>volatile</code>修饰<code>signleton</code>实例变量有效，解决该问题。</p><h3 id="1-6-静态内部类懒汉式"><a href="#1-6-静态内部类懒汉式" class="headerlink" title="1.6 静态内部类懒汉式"></a>1.6 静态内部类懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。<strong>目前此方式是所有单例模式中最推荐的模式</strong>，但具体还是根据项目选择。</p><hr><p>众所周知，单例模式是创建型模式，都会新建一个实例。那么一个重要的问题就是反序列化。当实例被写入到文件到反序列化成实例时，我们需要重写<code>readResolve</code>方法，以让实例唯一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><p>工厂顾名思义就是创建产品，根据产品是具体产品还是具体工厂可分为简单工厂模式和工厂方法模式，根据工厂的抽象程度可分为工厂方法模式和抽象工厂模式。</p><p>也就是说，工厂模式可分为<strong>简单工厂模式</strong>、<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>三种，这里放在这一起分析。</p><h3 id="2-1-简单工厂模式"><a href="#2-1-简单工厂模式" class="headerlink" title="2.1 简单工厂模式"></a>2.1 简单工厂模式</h3><p>简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。其UML类图如下：</p><img src="/images/java/1601019172(1).jpg" class="lazyload" data-srcset="/images/java/1601019172(1).jpg" srcset="data:image/png;base64,666"><h4 id="2-1-1-代码实现"><a href="#2-1-1-代码实现" class="headerlink" title="2.1.1 代码实现"></a>2.1.1 代码实现</h4><p>下面我们使用电脑生产来讲解该模式：</p><p><strong>Computer类：</strong>电脑标准规范类(AbstractProduct)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品的抽象方法，由具体的产品类去实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LenovoComputer类：</strong>制造联想电脑（Product1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产联想电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>AsusComputer类：</strong>制造华硕电脑（Product2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsusComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;生产华硕电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>创建工厂类（Factory）</strong></p><p>它提供了一个静态方法createComputer用来生产电脑。你只需要传入你想生产的电脑的品牌，它就会实例化相应品牌的电脑对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Computer <span class="title">createComputer</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        Computer mComputer=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;lenovo&quot;</span>:</span><br><span class="line">                mComputer=<span class="keyword">new</span> LenovoComputer();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;asus&quot;</span>:</span><br><span class="line">                mComputer=<span class="keyword">new</span> AsusComputer();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mComputer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  通常的做法是通过引入配置文件的方式，这里为了减少代码量，所以采用最简便的方式。</p></blockquote><p><strong>客户端调用工厂类</strong></p><p>客户端调用工厂类，传入“asus”生产出华硕电脑并调用该电脑对象的make方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreatComputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">      ComputerFactory.createComputer(<span class="string">&quot;asus&quot;</span>).make();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-优缺点"><a href="#2-1-2-优缺点" class="headerlink" title="2.1.2 优缺点"></a>2.1.2 优缺点</h4><p><strong>优点：</strong></p><ul><li>使用户根据参数获得对应的类实例，避免了直接实例化类，降低了耦合性。</li></ul><p><strong>缺点：</strong></p><ul><li>可实例化的类型在编译期间已经被确定，如果增加新类型，则需要修改工厂；</li><li><strong>违背了开放封闭原则(ASD)</strong> ；</li><li>简单工厂需要知道所有要生成的类型，当子类过多或者子类层次过多时不适合使用。</li></ul><h4 id="2-1-3-应用场景"><a href="#2-1-3-应用场景" class="headerlink" title="2.1.3 应用场景"></a>2.1.3 应用场景</h4><p>JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">()</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DateFormat <span class="title">getDateInstance</span><span class="params">(<span class="keyword">int</span> style,Locale locale)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-工厂方法模式"><a href="#2-2-工厂方法模式" class="headerlink" title="2.2 工厂方法模式"></a>2.2 工厂方法模式</h3><p>和简单工厂模式中工厂负责生产所有产品相比，工厂方法模式将生成具体产品的任务分发给具体的产品工厂，其UML类图如下：</p><img src="/images/java/1601019270(1).jpg" class="lazyload" data-srcset="/images/java/1601019270(1).jpg" srcset="data:image/png;base64,666"><p>也就是定义一个抽象工厂，其定义了产品的生产接口，但不负责具体的产品，将生产任务交给不同的派生类工厂，这样不用通过指定类型来创建对象了。</p><h4 id="2-2-1-代码实现"><a href="#2-2-1-代码实现" class="headerlink" title="2.2.1 代码实现"></a>2.2.1 代码实现</h4><p>接下来使用生产手机的例子来讲解该模式。</p><p><strong>产品类</strong></p><p><strong>Phone类</strong>：手机标准规范类(AbstractProduct)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MiPhone类</strong>：制造小米手机（Product1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make xiaomi phone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IPhone类</strong>：制造苹果手机（Product2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhone</span> <span class="keyword">implements</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make iphone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工厂类</strong></p><p><strong>AbstractFactory类</strong>：生产不同产品的工厂的抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Phone <span class="title">makePhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>XiaoMiFactory类</strong>：生产小米手机的工厂（ConcreteFactory1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AppleFactory类</strong>：生产苹果手机的工厂（ConcreteFactory2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">implements</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        AbstractFactory miFactory = <span class="keyword">new</span> XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        miFactory.makePhone();            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        appleFactory.makePhone();        <span class="comment">// make iphone!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-优缺点"><a href="#2-2-2-优缺点" class="headerlink" title="2.2.2 优缺点"></a>2.2.2 优缺点</h4><p><strong>优点：</strong></p><ul><li>在工厂方法模式中，工厂方法用来创建客户端所需要的产品，同时还向客户端<strong>隐藏了哪种具体产品类将被实例化这一细节</strong>，客户端只需要关心所需产品对应的工厂，无须关心创建细节，甚至<strong>无须知道具体产品类的类名</strong>。</li><li>使用工厂方法模式的另一个优点是在<strong>系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了</strong>。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><p><strong>缺点：</strong></p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，<strong>系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销</strong>。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用<strong>抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术</strong>，增加了系统的实现难度。</li></ul><h3 id="2-3-抽象工厂模式"><a href="#2-3-抽象工厂模式" class="headerlink" title="2.3 抽象工厂模式"></a>2.3 抽象工厂模式</h3><p>抽象工厂模式可以说是是工厂方法模式的升级版，当需要创建的产品<strong>有多个产品线（产品族）</strong>时使用抽象工厂模式是比较好的选择。</p><p>上面两种模式不管工厂怎么拆分抽象，都只是针对一类产品<strong>Phone</strong>（AbstractProduct），如果要生成另一种产品PC，应该怎么表示呢？</p><p>最简单的方式是把2中介绍的工厂方法模式完全复制一份，不过这次生产的是PC。但同时也就意味着我们要完全复制和修改Phone生产管理的所有代码，显然这是一个笨办法，并不利于扩展和维护。</p><p>抽象工厂模式通过在AbstarctFactory中增加创建产品的接口，并在具体子工厂中实现新加产品的创建，当然前提是子工厂支持生产该产品。其UML类图如下：</p><p><img src="/images/java/1601019317(1).jpg" class="lazyload" data-srcset="/images/java/1601019317(1).jpg" srcset="data:image/png;base64,666"></p><h4 id="2-3-1-代码实现"><a href="#2-3-1-代码实现" class="headerlink" title="2.3.1 代码实现"></a>2.3.1 代码实现</h4><p><strong>手机产品类</strong></p><p><strong>Phone 抽象产品类</strong>：手机标准规范类(AbstractProduct)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> Phone &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MiPhone 具体产品类</strong>：制造小米手机（Product1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make xiaomi phone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IPhone 具体产品类</strong>：制造苹果手机（Product2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make iphone!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>电脑产品类</p><p><strong>PC 抽象产品类</strong>：定义PC产品的抽象类(AbstractPC)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> PC &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">make</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MiPC 具体产品类</strong>：定义小米电脑产品(MIPC)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiPC</span> <span class="keyword">extends</span> <span class="title">PC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MiPC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make xiaomi PC!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>MAC 具体产品类</strong>：定义苹果电脑产品(MAC)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MAC</span> <span class="keyword">extends</span> <span class="title">PC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MAC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.make();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">make</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">&quot;make MAC!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂相关的类</p><p><strong>AbstractFactory 抽象工厂类</strong>：增加PC产品制造抽象类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractFactory &#123;</span><br><span class="line">    <span class="function">Phone <span class="title">makePhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">PC <span class="title">makePC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>XiaoMiFactory 具体工厂类</strong>：增加小米PC的制造（ConcreteFactory1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaoMiFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PC <span class="title">makePC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>AppleFactory 具体工厂类</strong>：增加苹果PC的制造（ConcreteFactory2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppleFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">makePhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PC <span class="title">makePC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MAC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>demo演示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] arg)</span> </span>&#123;</span><br><span class="line">        AbstractFactory miFactory = <span class="keyword">new</span> XiaoMiFactory();</span><br><span class="line">        AbstractFactory appleFactory = <span class="keyword">new</span> AppleFactory();</span><br><span class="line">        miFactory.makePhone();            <span class="comment">// make xiaomi phone!</span></span><br><span class="line">        miFactory.makePC();                <span class="comment">// make xiaomi PC!</span></span><br><span class="line">        appleFactory.makePhone();        <span class="comment">// make iphone!</span></span><br><span class="line">        appleFactory.makePC();            <span class="comment">// make MAC!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小总结</strong></p><p>看起来抽象工厂模式和工厂方法模式差不多，不过它们的区别在于增加产品上；</p><blockquote><p>  工厂方法模式支持新增同一个产品等级的产品，例如已经有Iphone的情况下增加Miphone。</p><p>  而抽象工厂模式支持新增同一产品族，例如在已经有Iphone,MAC的情况下同时增加MiPhone和MiPC。</p><p>  前者是每次只增加一个产品，后者是每次增加一组互相有关联的产品（产品族）。</p></blockquote><h4 id="2-3-2-优缺点"><a href="#2-3-2-优缺点" class="headerlink" title="2.3.2 优缺点"></a>2.3.2 优缺点</h4><p><strong>优点：</strong></p><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易。所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。另外，应用抽象工厂模式可以实现高内聚低耦合的设计目的，因此抽象工厂模式得到了广泛的应用；</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。这对一些需要根据当前环境来决定其行为的软件系统来说，是一种非常实用的设计模式；</li><li>增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><p><strong>缺点：</strong></p><ul><li><p>在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，<strong>要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便</strong></p></li><li><p>开闭原则的倾斜性</p><p>(1) 增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了“开闭原则”，只需要增加具体产品并对应增加一个新的具体工厂，对已有代码无须做任何修改。</p><p>(2) 增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，违背了“开闭原则”。</p></li></ul><blockquote><p>  正因为抽象工厂模式存在“开闭原则”的倾斜性，它以一种倾斜的方式来满足“开闭原则”，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就能够全面考虑，不会在设计完成之后向系统中增加新的产品等级结构，也不会删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续维护工作带来诸多麻烦。</p></blockquote><h4 id="2-3-3-三种工厂模式的转换"><a href="#2-3-3-三种工厂模式的转换" class="headerlink" title="2.3.3 三种工厂模式的转换"></a>2.3.3 三种工厂模式的转换</h4><ul><li>当<strong>抽象工厂模式</strong>中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成<strong>工厂方法模式</strong> ；</li><li>当<strong>工厂方法模式</strong>中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成<strong>简单工厂模式</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql-Explain性能分析</title>
      <link href="2020/12/22/mysql-explain%E4%BC%98%E5%8C%96/"/>
      <url>2020/12/22/mysql-explain%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>使用EXPLAIN 关键字可以模拟优化器执行SQL 查询语句，从而知道MySQL 是如何处理你的SQL 语句的。分<br>析你的查询语句或是表结构的性能瓶颈。</p><p><strong>用法：Explain+SQL 语句；</strong></p><p>Explain 执行后返回的信息：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201222164544897-296518114.png" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201222164544897-296518114.png" srcset="data:image/png;base64,666" alt="img"/></div><span class="image-caption">img</span></div><h3 id="explain-字段分析"><a href="#explain-字段分析" class="headerlink" title="explain 字段分析"></a>explain 字段分析</h3><table><thead><tr><th>字段</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>选择标识符</td></tr><tr><td>select_type</td><td>表示查询的类型</td></tr><tr><td>table</td><td>输出结果集的表</td></tr><tr><td>partitions</td><td>匹配的分区</td></tr><tr><td>type</td><td>表示表的连接类型</td></tr><tr><td>possible_keys</td><td>表示查询时，可能使用的索引</td></tr><tr><td>key</td><td>表示实际使用的索引</td></tr><tr><td>key_len</td><td>索引字段的长度</td></tr><tr><td>ref</td><td>列与索引的比较</td></tr><tr><td>rows</td><td>扫描出的行数(估算的行数)</td></tr><tr><td>filtered</td><td>按表条件过滤的行百分比</td></tr><tr><td>Extra</td><td>执行情况的描述和说明</td></tr></tbody></table><h3 id="字段属性分析"><a href="#字段属性分析" class="headerlink" title="字段属性分析"></a>字段属性分析</h3><p><strong>一、id</strong></p><p>select 查询的序列号,包含一组数字，表示查询中执行select 子句或操作表的顺序。</p><ol><li><strong>id 相同</strong>，执行顺序由上至下；</li><li><strong>id 不同</strong>，如果是子查询，id 的序号会递增，<strong>id 值越大优先级越高，越先被执行</strong>；</li><li><strong>id 有相同也有不同</strong>，id 如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id 值越大，优先级越高，越先执行衍生( DERIVED )</li></ol><blockquote><p>  【关注点】id 号每个号码，表示一趟独立的查询。一个sql 的查询趟数越少越好。</p></blockquote><hr><p><strong>二、select_type</strong></p><p>select_type 代表查询的类型，主要是用于区别普通查询、联合查询、子查询等的复杂查询。</p><ul><li><strong>SIMPLE</strong>：简单的select 查询,查询中不包含子查询或者UNION</li><li><strong>PRIMARY</strong>：  查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</li><li><strong>DERIVED</strong>：  在FROM 列表中包含的子查询被标记为DERIVED(衍生)。MySQL 会递归执行这些子查询, 把结果放在临时表里。</li><li><strong>SUBQUERY</strong>：  在SELECT或WHERE列表中包含了子查询</li><li><strong>DEPEDENT SUBQUERY</strong>：在SELECT或WHERE列表中包含了子查询,子查询基于外层</li><li><strong>UNCACHEABLE SUBQUERY</strong>：  无法使用缓存的子查询</li><li><strong>UNION</strong>：  若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</li><li><strong>UNION RESULT</strong>：从UNION表获取结果的SELECT</li></ul><hr><p><strong>三、table</strong></p><p>表示这个数据是基于哪张表的。</p><p><strong>四、type</strong></p><p>type 是查询的访问类型。是较为重要的一个指标，结果值从最好到最坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; <strong>range</strong> &gt; <strong>index</strong> &gt; <strong>ALL</strong></p><p><strong>不过在实际应用中常用到的只有：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong></p><ul><li><strong>system</strong>：表只有一行记录（等于系统表），这是 const 类型的特列，平时不会出现，这个可以忽略不计</li><li><strong>const</strong>：表示通过索引一次就找到了, const 用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。例如将主键置于 where 列表中，MySQL 就能将该查询转换为一个常量。</li><li><strong>eq_ref</strong>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描。</li><li><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行</li><li><strong>range</strong>：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引一般就是在你的 where 语句中出现<br>了 between、&lt;、&gt;、in 等的查询这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而<br>结束语另一点，不用扫描全部索引。</li><li><strong>index</strong>：出现 index 是 sql <strong>使用了索引但是没用通过索引进行过滤</strong>，一般是使用了<strong>覆盖索引</strong>或者是<strong>利用索引进行了排序分组</strong>。</li><li><strong>ALL</strong>：Full Table Scan，将遍历全表以找到匹配的行。</li></ul><blockquote><p>  【提示】</p><p>  一般来说，得保证查询至少达到 range 级别，最好能达到 ref。</p></blockquote><hr><p><strong>五、 possible_keys</strong></p><p>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，<strong>但不一定被查询实际使用</strong>。</p><p><strong>六、key</strong></p><p>实际使用的索引。如果为NULL，则没有使用索引。</p><p><strong>七、key_len</strong></p><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。key_len 字段能够帮你检查是否充分的利用上了索引。<strong>ken_len 越长，说明索引使用的越充分。</strong></p><p><strong>八、ref</strong></p><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。<strong>哪些列或常量被用于查找索引列上的值</strong>。</p><p><strong>九、rows</strong></p><p><strong>rows 列显示MySQL 认为它执行查询时必须检查的行数。越少越好！</strong></p><p><strong>十、Extra</strong></p><p>该列包含不适合在其他列显示但十分重要的额外信息。有以下几种情况：</p><ul><li>Using filesort：说明mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。<strong>MySQL 中无法利用索引完成的排序操作称为“文件排序”</strong>。</li><li>Using temporary：使了用临时表保存中间结果, MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</li><li>Using index：Using index 代表表示相应的 select 操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！如果同时出现 using where，表明索引被用来执行索引键值的查找;如果没有同时出现 using where，表明索引只是用来读取数据而非利用索引执行查找。</li><li>Using where：表明使用了where 过滤。</li><li>Using join buffer：使用了连接缓存。</li><li>impossible where：where 子句的值总是 false，不能用来获取任何元组。</li><li>select tables optimized away：在没有 GROUPBY 子句的情况下，基于索引优化 MIN / MAX 操作或者对于 MyISAM 存储引擎优化 COUNT(*) 操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</li></ul><blockquote><p>  <strong>覆盖索引</strong>：select 的数据列只用从索引中就能够取得，不必读取数据行，MySQL 可以利用索引返回列表中的字段，而不必根据索引再次读取数据文件，即查询列要被所建的索引覆盖。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java 线程进阶</title>
      <link href="2020/11/24/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
      <url>2020/11/24/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; 计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的<strong>高速缓存</strong>（Cache）来作为内存与处理器之间的缓冲：<strong>将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了</strong></p><blockquote><p>  在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。</p><p>  所以当多个处理器的运算任务涉及同一块主内存区域时，就有可能导致各自缓存的数据不一致。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjBhOTk2ODc0NmFmYTJhZmRlNGIzNzE2YmFiZjU1Y2U_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" class="lazyload" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjBhOTk2ODc0NmFmYTJhZmRlNGIzNzE2YmFiZjU1Y2U_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" srcset="data:image/png;base64,666"></p><p><strong>Java内存模型</strong> </p><p>&nbsp;&nbsp;&nbsp;&nbsp; Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model,JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。</p><p>在 java 中每个线程有自己的工作内存进行数据处理，但是它们共用一个主内存。在线程处理数据的时候只是把数据从主内存中拷贝一份副数据到工作内存进行处理，然后再将处理结果同步到主内存中。但这些都是需要时间的，也就是说如果多个线程处理同一个数据，就会出现结果与我们预料不一致的情况，<strong>也就是我们常说的线程安全问题。</strong></p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" class="lazyload" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOGY5ODMzMGRjOGFmNGNlOGNmNTM5N2EwMTMzMDhlYzI_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" srcset="data:image/png;base64,666"><blockquote><p>  【注意】这里所讲的主内存、工作内存与我们通常所讲的Java内存区域中的 Java 堆、栈、方法区等并不是同一个层次的内存划分，这两者基本上是没有关系的，如果两者一定要勉强对应起来，那从变量、主内存、工作内存的定义来看，主内存主要对应于 Java 堆中的对象实例数据部分，而工作内存则对应于虚拟机栈中的部分区域。</p></blockquote><h2 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h2><p><strong>什么是线程安全？</strong></p><p>定义：如果一个对象可以安全地被多个线程同时使用，那它就是线程安全的。</p><p>线程安全的实现方法可分为：互斥同步、非阻塞同步</p><h3 id="1-1-互斥同步"><a href="#1-1-互斥同步" class="headerlink" title="1.1 互斥同步"></a>1.1 互斥同步</h3><p>同步是指在多个线程并发访问共享数据时，保证共享数据再同一个时刻只被一个线程使用。而互斥是实现同步的一种手段，临界区、互斥量、信号量都是主要的互斥的实现方式。</p><p>实现同步的方式有：synchronized 关键字、RenntrantLock 重入锁</p><p>对于 synchronized 同步块而言，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入。但 Java 线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这些都是需要消耗处理器时间的，这其中消耗的时间可能比用户代码执行的时间还要长，<strong>所以 synchronized 是 Java 语言中一个重量级的操作。</strong></p><p>RenntrantLock 增加啊了一些高级功能：</p><ol><li><strong>等待可中断：</strong>当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>可实现公平锁：</strong>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁。而非公平锁不保证这点，锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized 的锁是非公平的，RenntrantLock 默认也是非公平，但可以通过带有布尔值的构造函数要求使用公平锁。</li><li><strong>锁可绑定多个条件：</strong>RenntrantLock 对象可以同时绑定多个 Condition 对象，只需多次调用 newCondition() 方法即可。</li></ol><blockquote><p>  【对比】synchronized 和 RenntrantLock 从性能上考虑，在 JDK 1.6 之后 synchronized 性能更好，所以还是提倡在 synchronized 能实现需求的情况下，优先使用 synchronized 来进行同步。</p></blockquote><h3 id="1-2-非阻塞同步"><a href="#1-2-非阻塞同步" class="headerlink" title="1.2 非阻塞同步"></a>1.2 非阻塞同步</h3><p>互斥同步做主要的问题就是进行线程阻塞和唤醒所带来的性能问题，这种同步也称之为阻塞同步。</p><p>随着硬件指令集的发展，我们又了另一种乐观的并发策略：通俗地说就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；<strong>如果共享数据有争用，产生了冲突，那就采取补偿措施（最常见的措施就是不断尝试，直到成功为止）</strong>，这种策略不需要把线程挂起，因此称为<strong>非阻塞同步</strong>。</p><p>我们需要保证操作和冲突检测这两个步骤具备原子性，就需要用到硬件指令来完成。目前最常用的指令是：<strong>比较并交换（ Compare-and-Swap，也称为 CAS 指令）。</strong></p><p>CAS 指令：需要有 3 个操作数，分别是内存地址（用 V 表示），旧的预估值（用 A 表示）和新值（用 B 表示）。<strong>CAS 执行执行时，当且仅当 V 的值与 A 一致时，处理器才用新值 B 更新 V 的值，否则就不执行更新。</strong>这个处理过程是一个原子操作。</p><h2 id="2-锁优化"><a href="#2-锁优化" class="headerlink" title="2. 锁优化"></a>2. 锁优化</h2><p>高效并发是从JDK 1.5到JDK 1.6的一个重要改进，HotSpot虚拟机开发团队在这个版本上花费了大量的精力去实现各种锁优化技术，如<strong>适应性自旋</strong>（Adaptive Spinning）、<strong>锁消除</strong>（Lock Elimination）、<strong>锁粗化</strong>（Lock Coarsening）、<strong>轻量级锁</strong>（Lightweight Locking）和<strong>偏向锁</strong>（Biased Locking）等，这些技术都是为了在线程之间更高效地共享数据，以及解决竞争问题，从而提高程序的执行效率。</p><h3 id="2-1-适应性自旋锁"><a href="#2-1-适应性自旋锁" class="headerlink" title="2.1 适应性自旋锁"></a>2.1 适应性自旋锁</h3><p>前面提到了互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。同时，虚拟机的开发团队也注意到在许多应用上，共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的<strong>自旋锁</strong>。</p><p>在JDK 1.6中引入了<strong>自适应的自旋锁</strong>。自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。另外，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确，虚拟机就会变得越来越“聪明”了。</p><h3 id="2-2-锁消除"><a href="#2-2-锁消除" class="headerlink" title="2.2 锁消除"></a>2.2 锁消除</h3><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就无须进行。</p><h3 id="2-3-锁粗化"><a href="#2-3-锁粗化" class="headerlink" title="2.3 锁粗化"></a>2.3 锁粗化</h3><p>原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待锁的线程也能尽快拿到锁。</p><p>大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。</p><h3 id="2-4-偏向锁"><a href="#2-4-偏向锁" class="headerlink" title="2.4 偏向锁"></a>2.4 偏向锁</h3><p>偏向锁也是JDK 1.6中引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p><p>偏向锁的“偏”，就是偏心的“偏”、偏袒的“偏”，它的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>]]></content>
      
      
      <categories>
          
          <category> Java核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构--二叉树</title>
      <link href="2020/11/17/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2020/11/17/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p> 树是一种比较重要的数据结构，尤其是二叉树。在这里简单介绍二叉树。</p><p>二叉树是一种特殊的树，在二叉树中每个节点最多有两个子节点，一般称为左子节点和右子节点（或左孩子和右孩子），并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><h2 id="1-二叉树"><a href="#1-二叉树" class="headerlink" title="1. 二叉树"></a>1. 二叉树</h2><h3 id="1-1-普通二叉树"><a href="#1-1-普通二叉树" class="headerlink" title="1.1 普通二叉树"></a>1.1 普通二叉树</h3><p>二叉树是n(n&gt;=0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树组成。</p><p>如下是一棵普通的二叉树：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116162247751-41519761.jpg" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116162247751-41519761.jpg" srcset="data:image/png;base64,666"></p><p><strong>二叉树特点：</strong></p><ol><li>每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</li></ol><h3 id="1-2-斜树"><a href="#1-2-斜树" class="headerlink" title="1.2 斜树"></a>1.2 斜树</h3><p><strong>定义：</strong>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><p>如下是一棵右斜树：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116162807572-1429303018.jpg" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116162807572-1429303018.jpg" srcset="data:image/png;base64,666"></p><h3 id="1-3-满二叉树"><a href="#1-3-满二叉树" class="headerlink" title="1.3 满二叉树"></a>1.3 满二叉树</h3><p><strong>定义：</strong>在一棵二叉树中。如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p><p>如下是一棵满二叉树：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116163339467-2073237953.jpg" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116163339467-2073237953.jpg" srcset="data:image/png;base64,666"></p><p><strong>满二叉树的特点：</strong></p><ol><li>叶子只能出现在最下一层。出现在其它层就不可能达成平衡。</li><li>非叶子结点的度一定是2。</li><li>在同样深度的二叉树中，满二叉树的结点个数最多，叶子数最多。</li></ol><h3 id="1-4-完全二叉树"><a href="#1-4-完全二叉树" class="headerlink" title="1.4 完全二叉树"></a>1.4 完全二叉树</h3><p><strong>定义：</strong>对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><p>如下是一棵完全二叉树：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116164106235-2055196522.jpg" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116164106235-2055196522.jpg" srcset="data:image/png;base64,666"></p><p><strong>完全二叉树的特点：</strong></p><ol><li>叶子结点只能出现在最下层和次下层。</li><li>最下层的叶子结点集中在树的左部。</li><li>倒数第二层若存在叶子结点，一定在右部连续位置。</li><li>如果结点度为1，则该结点只有左孩子，即没有右子树。</li><li>同样结点数目的二叉树，完全二叉树深度最小。</li></ol><blockquote><p>  【区别】</p><p>  也就是说，在满叉树的基础上，我在最底层从右往左删去若干节点，得到的都是完全二叉树。</p><p>  所以说，满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树</p></blockquote><h3 id="1-5-二叉树的使用场景"><a href="#1-5-二叉树的使用场景" class="headerlink" title="1.5 二叉树的使用场景"></a>1.5 二叉树的使用场景</h3><p>普通的二叉树，很难构成现实的应用场景，但因其简单，常用于学习研究，平衡二叉树则是实际应用比较多的。常见于快速匹配、搜索等方面。</p><p>常用的树有：<strong>AVL树、红黑树、B/B+树、Trie（字典）树</strong>。</p><ul><li>AVL树：最早的平衡二叉树之一。应用相对其他数据结构比较少。windows对进程地址空间的管理用到了AVL树。</li><li>红黑树：集合map和set都是用红黑树实现的。还有Linux文件管理。</li><li>B/B+树：用在磁盘文件组织 数据索引和数据库索引。</li><li>Trie树(字典树): 用在统计和排序大量字符串，如自动机、M数据库索引。</li></ul><hr><h2 id="2-二叉树的遍历"><a href="#2-二叉树的遍历" class="headerlink" title="2. 二叉树的遍历"></a>2. 二叉树的遍历</h2><h3 id="2-1-存储方式"><a href="#2-1-存储方式" class="headerlink" title="2.1 存储方式"></a>2.1 存储方式</h3><p>二叉树的存储分为<strong>顺序存储</strong>和<strong>链式存储</strong> 。顺序存储在右斜树这种极端情况下，会十分浪费存储空间，顺序存储结构一般适用于完全二叉树。因此二叉树的存储一般会使用链式存储，在这里只介绍链式存储：</p><p>二叉树的链式存储结构，将节点的数据结构定义为一个数据域和两个指针域，如下图所示：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116171705071-1987504128.jpg" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116171705071-1987504128.jpg" srcset="data:image/png;base64,666"></p><p>则完整的二叉树可以表示为：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116171858740-2061961162.jpg" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116171858740-2061961162.jpg" srcset="data:image/png;base64,666"></p><p>对于节点的声明，使用java代码可如下声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    String data;</span><br><span class="line">    TreeNode LChild;</span><br><span class="line">    TreeNode RChild;</span><br><span class="line">    TreeNode(String data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-遍历方式"><a href="#2-2-遍历方式" class="headerlink" title="2.2 遍历方式"></a>2.2 遍历方式</h3><p>二叉树的遍历是指从二叉树的根结点出发，按照某种次序依次访问二叉树中的所有结点，使得每个结点被访问一次，且仅被访问一次。</p><p>二叉树的遍历方式可以分为四种：</p><ul><li>前序遍历：root &gt;&gt; left &gt;&gt; right</li><li>中序遍历：left &gt;&gt; root &gt;&gt; right</li><li>后续遍历：left &gt;&gt; right &gt;&gt; root</li><li>层序遍历：按照层次遍历</li></ul><p><img src="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116173645589-356529035.jpg" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116173645589-356529035.jpg" srcset="data:image/png;base64,666"></p><p>对于如上图二叉树的遍历结果为：</p><p>前序遍历：ABCDEFGHK</p><p>中序遍历：BDCAEHGKF</p><p>后序遍历：DCBHKGFEA</p><blockquote><p>  <strong>前序遍历</strong>就是从二叉树的根结点出发，当第一次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p><p>  <strong>中序遍历</strong>就是从二叉树的根结点出发，当第二次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p><p>  <strong>后序遍历</strong>就是从二叉树的根结点出发，当第三次到达结点时就输出结点数据，按照先向左在向右的方向访问。</p></blockquote><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3. 代码实现"></a>3. 代码实现</h2><h3 id="3-1-定义二叉树节点存储结构"><a href="#3-1-定义二叉树节点存储结构" class="headerlink" title="3.1 定义二叉树节点存储结构"></a>3.1 定义二叉树节点存储结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        String root;</span><br><span class="line">        TreeNode LChild;</span><br><span class="line">        TreeNode RChild;</span><br><span class="line"></span><br><span class="line">        TreeNode(String root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-构建二叉树"><a href="#3-2-构建二叉树" class="headerlink" title="3.2 构建二叉树"></a>3.2 构建二叉树</h3><p>对于二叉树的构建，使用前序遍历构建比较合适也较为简单。但是在构建的时候要使二叉树左右子树都有数据，如下图为要构建的二叉树：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116173645589-356529035.jpg" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201116173645589-356529035.jpg" srcset="data:image/png;base64,666"></p><p>在构建时要表示为如下的二叉树：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201117140253401-946934983.jpg" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202011/1506061-20201117140253401-946934983.jpg" srcset="data:image/png;base64,666"></p><blockquote><p>  对于阴影的部分我们使用 ”.“ 表示，即以上的二叉树我们可用数组表示为：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] tree &#x3D; &#123;&quot;A&quot;, &quot;B&quot;, &quot;.&quot;, &quot;C&quot;, &quot;D&quot;, &quot;.&quot;, &quot;.&quot;, &quot;.&quot;, &quot;E&quot;, &quot;.&quot;, &quot;F&quot;, &quot;G&quot;,&quot;H&quot;,&quot;.&quot;, &quot;.&quot;,&quot;k&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="3-3-完整代码"><a href="#3-3-完整代码" class="headerlink" title="3.3 完整代码"></a>3.3 完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        String root;</span><br><span class="line">        TreeNode LChild;</span><br><span class="line">        TreeNode RChild;</span><br><span class="line"></span><br><span class="line">        TreeNode(String root) &#123;</span><br><span class="line">            <span class="keyword">this</span>.root = root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] install = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;.&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>,<span class="string">&quot;H&quot;</span>,<span class="string">&quot;.&quot;</span>, <span class="string">&quot;.&quot;</span>,<span class="string">&quot;k&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>,<span class="string">&quot;.&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//使用前序遍历构建二叉树</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">createBTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        TreeNode treeNode = <span class="keyword">null</span>;</span><br><span class="line">        String data = install[i++];</span><br><span class="line">        <span class="keyword">if</span> (data.equals(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> treeNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            treeNode = <span class="keyword">new</span> TreeNode(data);</span><br><span class="line">            treeNode.LChild = createBTree();</span><br><span class="line">            treeNode.RChild = createBTree();</span><br><span class="line">            <span class="keyword">return</span> treeNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrderTree</span><span class="params">(TreeNode tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(tree + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            preOrderTree(tree.LChild);</span><br><span class="line">            preOrderTree(tree.RChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inOrderTree</span><span class="params">(TreeNode tree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inOrderTree(tree.LChild);</span><br><span class="line">            System.out.print(tree + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            inOrderTree(tree.RChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后续遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterOrderTree</span><span class="params">(TreeNode tree)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tree != <span class="keyword">null</span>) &#123;</span><br><span class="line">            afterOrderTree(tree.LChild);</span><br><span class="line">            afterOrderTree(tree.RChild);</span><br><span class="line">            System.out.print(tree + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//层序遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode tree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(tree == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(tree.LChild);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(tree.RChild);</span><br><span class="line">        <span class="keyword">return</span> (left &gt; right) ? (left+<span class="number">1</span>) : (right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TreeTest test = <span class="keyword">new</span> TreeTest();</span><br><span class="line">        TreeNode bTree = test.createBTree();</span><br><span class="line">        test.preOrderTree(bTree);    <span class="comment">//A B C D E F G H k </span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        test.inOrderTree(bTree);    <span class="comment">//B D C A E H G k F </span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        test.afterOrderTree(bTree);    <span class="comment">//D C B H k G F E A </span></span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">int</span> depth = test.TreeDepth(bTree);</span><br><span class="line">        System.out.println(depth);    <span class="comment">//5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程基础学习笔记</title>
      <link href="2020/11/16/java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>2020/11/16/java%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程基本概念"><a href="#1-线程基本概念" class="headerlink" title="1. 线程基本概念"></a>1. 线程基本概念</h2><h3 id="1-1-线程与进程"><a href="#1-1-线程与进程" class="headerlink" title="1.1 线程与进程"></a>1.1 线程与进程</h3><p>当一个程序进入内存运行时，即变成一个进程。进程是系统进行资源分配和调度的一个独立单元。</p><p>线程是进程的组成部分，一个进程可以拥有多个线程，一个线程必须有一个父进程。</p><blockquote><p>  归纳起来说就是：操作系统可以同时执行多个任务，每个任务就是进程；而进程也可以同时执行多个任务，每个任务就是线程。</p></blockquote><h3 id="1-2-并发与并行"><a href="#1-2-并发与并行" class="headerlink" title="1.2 并发与并行"></a>1.2 并发与并行</h3><p>并行：在同一时刻，有多条指令在多个处理器上同时执行</p><p>并发：在同一时刻，只能有一条指令执行，但多个指令在一个处理器上被快速轮流切换执行。</p><h2 id="2-线程的创建与启动"><a href="#2-线程的创建与启动" class="headerlink" title="2. 线程的创建与启动"></a>2. 线程的创建与启动</h2><p><strong>线程创建有4种方式，但是线程的启动只能调用线程对象的start() 方法</strong></p><p>创建线程有以下4种方式：</p><ol><li>继承 Thread 类</li><li>实现 Runnable 接口</li><li>实现 Callable 接口</li><li>线程池</li></ol><h3 id="2-1-继承Thread抽象类"><a href="#2-1-继承Thread抽象类" class="headerlink" title="2.1 继承Thread抽象类"></a>2.1 继承Thread抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(getName()+ <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="keyword">new</span> Thread1().start();</span><br><span class="line">                <span class="keyword">new</span> Thread1().start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208112902783-377538696.png" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208112902783-377538696.png" srcset="data:image/png;base64,666"></p><h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>)&#123;</span><br><span class="line">                <span class="comment">//Lambda表达式实现runnable接口</span></span><br><span class="line">                <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j= <span class="number">0</span>; j&lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;, <span class="string">&quot;线程2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Lambda表达式实现runnable接口</span></span><br><span class="line">                <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">                            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; &quot;</span> + j);</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;, <span class="string">&quot;线程1&quot;</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208113221333-2130705942.png" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208113221333-2130705942.png" srcset="data:image/png;base64,666"></p><h3 id="2-3-实现Callable接口"><a href="#2-3-实现Callable接口" class="headerlink" title="2.3 实现Callable接口"></a>2.3 实现Callable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//使用FutureTask对象老包装 Callable 对象</span></span><br><span class="line">          <span class="comment">//Callable 对象含有返回值</span></span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(()-&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>( ; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">10</span>)&#123;</span><br><span class="line">                  <span class="comment">//start() 方法启动线程</span></span><br><span class="line">                <span class="keyword">new</span> Thread(task, <span class="string">&quot;有返回值的线程&quot;</span>).start();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">//通过FutureTask 对象的get() 方法获取返回值</span></span><br><span class="line">            System.out.println(<span class="string">&quot;子线程返回值：&quot;</span> + task.get());</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208113417698-2089956495.png" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208113417698-2089956495.png" srcset="data:image/png;base64,666"></p><blockquote><p>  先介绍以上三种，线程池后面细讲</p></blockquote><h3 id="2-4-三种方式对比"><a href="#2-4-三种方式对比" class="headerlink" title="2.4 三种方式对比"></a>2.4 三种方式对比</h3><p>从实现方式上对比，实现 Runnable 接口与实现 Callable 接口属于同一种线程启动的方式。</p><p>采用继承Thread类创建线程的方式有以下优缺点：</p><ul><li><strong>优势：编写简单，要获取当前线程不需要使用 Thread.currentThread() 方法，只需要使用 this 即可；</strong></li><li><strong>劣势：java只能单继承，因为线程类继承了 Thread 类就不能再继承其他父类。</strong></li></ul><p>采用实现 Runnable、Callable 接口方式有以下优缺点：</p><ul><li><strong>优势：实现接口后还能继承其他父类；</strong></li><li><strong>优势：在这种方式下，多个线程可以共享同一个目标对象，所以非常适合多个线程来处理同一份资源的情况（也就是生产者消费者模式）；</strong></li><li><strong>劣势：变成稍稍复杂，要使用 Thread.currentThread() 方法获取当前线程。</strong></li></ul><hr><h2 id="3-线程控制"><a href="#3-线程控制" class="headerlink" title="3. 线程控制"></a>3. 线程控制</h2><h3 id="3-1-线程生命周期"><a href="#3-1-线程生命周期" class="headerlink" title="3.1 线程生命周期"></a>3.1 线程生命周期</h3><p>在线程的生命周期中，要经过新建（New）、就绪（Runnable）、运行（Run）、阻塞（Blocked）、和死亡（Dead）5种状态。尤其是当线程启动后，它不能一直霸占着CPU独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会在多次运行、阻塞之间切换。</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208140238901-2035332028.png" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208140238901-2035332028.png" srcset="data:image/png;base64,666"></p><h3 id="3-2-join-线程"><a href="#3-2-join-线程" class="headerlink" title="3.2 join 线程"></a>3.2 join 线程</h3><blockquote><p>   =&gt; join(): 等待被join的线程执行完成；</p></blockquote><blockquote><p>  =&gt; join(long millis): 等待被join的线程时间最长为millis毫秒；</p></blockquote><p>当在某个程序执行过程中调用其他线程的 join() 方法，调用线程将被阻塞，直到被 join() 方法加入的 join 线程执行完为止。</p><p>【例】在一道程序中有A线程和B线程两个，在B线程中调用 A.join(); 则程序会在A线程执行完毕后才会开始执行B线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (; i&lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(getName()+ <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+ <span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>)&#123;</span><br><span class="line">                Thread1 t1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">                t1.start();</span><br><span class="line">                <span class="comment">//main 线程调用了t1 线程的join() 方法</span></span><br><span class="line">                <span class="comment">// 必须等t1 执行结束才会向下执行</span></span><br><span class="line">                t1.join();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208145557326-2071910976.png" class="lazyload" data-srcset="https://img2020.cnblogs.com/blog/1506061/202012/1506061-20201208145557326-2071910976.png" srcset="data:image/png;base64,666"></p><h3 id="3-3-线程睡眠：sleep"><a href="#3-3-线程睡眠：sleep" class="headerlink" title="3.3 线程睡眠：sleep"></a>3.3 线程睡眠：sleep</h3><p>static void sleep(long millis)：让当前正在执行的线程暂停 millis 毫秒，并进入阻塞状态；</p><p>static vold sleep(long millis, int nanos)：让当前正在执行的线程暂停 millis 毫秒加 nanos 毫微秒，并进入阻塞状态。</p><blockquote><p>  【注】调用sleep() 方法不会释放所占有的资源</p></blockquote><h3 id="3-4-线程等待：wait"><a href="#3-4-线程等待：wait" class="headerlink" title="3.4 线程等待：wait"></a>3.4 线程等待：wait</h3><p>wait() 是Object 基类的方法，作用与sleep 类似，使得线程进入等待队列。<strong>不同的是，当线程调用wait()方法后会进入等待队列（进入这个状态会释放所占有的所有资源，与阻塞状态不同）</strong></p><p>线程调用 wait() 方法后，要调用notify / notifyAll() 方法才能将其唤醒，进入就绪状态。</p><blockquote><p>  <strong>调用notify() 方法导致解除阻塞的线程是从因调用该对象的 wait()方法而阻塞的线程中随机选取的</strong>，我们无法预料哪一个线程将会被选择，所以编程时要特别小心，避免因这种不确定性而产生问题。</p><p>  <strong>调用 notifyAll()方法将把因调用该对象的 wait()方法而阻塞的所有线程一次性全部解除阻塞</strong> 。当然，只有获得锁的那一个线程才能进入可执行状态。</p></blockquote><h3 id="3-5-线程让步：yield"><a href="#3-5-线程让步：yield" class="headerlink" title="3.5 线程让步：yield"></a>3.5 线程让步：yield</h3><p>yield() 方法是一个和sleep() 方法有点相似的方法，它也可是 Thread 类提供的一个静态方法，它可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。</p><blockquote><p>  yield() 只是让当前线程暂停一下，让系统的线程调度器重新调用一次，完全可能的情况是：当某个线程调用了yield() 方法暂停后，线程调度器又将其重新调度出来执行。</p></blockquote><h3 id="3-6-线程优先级：setPriority"><a href="#3-6-线程优先级：setPriority" class="headerlink" title="3.6 线程优先级：setPriority"></a>3.6 线程优先级：setPriority</h3><p>每个线程执行时都具有一定的优先级，优先级高的线程会获得较多的执行机会。</p><p>每个线程默认的优先级都与创建它的父线程的优先级相同。（main 线程除外，默认情况下 main 线程创建的子线程和 main 线程都具有普通优先级）</p><blockquote><p>  Thread 类提供了 setPriority(int new Priority)、getPriority() 方法来设置和返回指定线程的优先级。范围的1~10之间。也可以使用 Thread 类的以下三个静态常量：</p><p>  MAX_PRIORITY：其值为10。</p><p>  MIN_PRIORITY：其值为1。</p><p>  NORM_PRIORITY：其值为5。</p></blockquote><hr><h2 id="4-线程同步"><a href="#4-线程同步" class="headerlink" title="4. 线程同步"></a>4. 线程同步</h2><p>解决线程安全问题的方式有：</p><ol><li>同步代码块</li><li>同步方法</li><li>同步锁（Lock）</li></ol><h3 id="4-1-同步代码块"><a href="#4-1-同步代码块" class="headerlink" title="4.1 同步代码块"></a>4.1 同步代码块</h3><p>线程开始执行同步代码块之前，必须先获得同步监视器的锁定。语法格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//此处的代码为同步代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  【注意】任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成后，该线程会释放对同步监视器的锁定。</p></blockquote><blockquote><p>  【提示】java 程序允许使用任意对象作为同步监视器，<strong>通常推荐使用可能被并发访问的共享资源充当同步监视器</strong>。</p></blockquote><h3 id="4-2-同步方法"><a href="#4-2-同步方法" class="headerlink" title="4.2 同步方法"></a>4.2 同步方法</h3><p>同步方法就是使用 synchronized 关键字来修饰某个方法。对于 synchronized 修饰的实例方法（非 static 方法）而言，同步方法的同步监视器就是 this，也就是调用该方法的对象。</p><blockquote><p>  JDK 所提供的 StringBuilder、StringBuffer 就是为了照顾单线程环境和多线程环境所提供的类。两个类代码几乎相似，只是 StringBuffer 的方法使用了synchronized 关键字修饰。</p><p>  所以在单线程环境下应该使用 StringBuilder 来保证较好的性能；多线程环境应使用 StringBuffer  来保证线程安全。</p></blockquote><h3 id="4-3-同步锁（Lock）"><a href="#4-3-同步锁（Lock）" class="headerlink" title="4.3 同步锁（Lock）"></a>4.3 同步锁（Lock）</h3><p>同步锁是比 synchronized 方法和 synchronized 代码块更细粒度的同步机制，由 Lock 对象充当。</p><p>在线程安全控制中，比较常用的是 ReentrantLock (可重入锁)。使用该Lock 对象可显示地加锁、释放锁，通常使用 ReentrantLock 的代码格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxx</span> </span>&#123;</span><br><span class="line">  <span class="comment">//定义锁对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">//定义需要保证线程安全的方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      <span class="comment">//需保证线程安全的代码</span></span><br><span class="line">      <span class="comment">//... method body</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;    <span class="comment">//使用 finally 块来保证释放锁</span></span><br><span class="line">      <span class="comment">//释放锁</span></span><br><span class="line">      lock.unlock;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-线程通信"><a href="#5-线程通信" class="headerlink" title="5. 线程通信"></a>5. 线程通信</h2><h3 id="5-1-传统的线程通信"><a href="#5-1-传统的线程通信" class="headerlink" title="5.1 传统的线程通信"></a>5.1 传统的线程通信</h3><p>传统的线程通信是借助于 Object 类提供的 wait()、notify()、notifyAll() 三个方法，结合 synchronized 修饰的同步方法或同步代码块实现的。在这里不做介绍。</p><h3 id="5-2-Condition-控制线程"><a href="#5-2-Condition-控制线程" class="headerlink" title="5.2 Condition 控制线程"></a>5.2 Condition 控制线程</h3><p>Java 提供了一个Condition 类，使用 Condition 可以让那些已经得到 Lock 对象却无法继续执行的线程释放 Lock对象，也可以唤醒    其他处于等待状态的线程。</p><p>Condition 将 Object 监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock 实现组合使用。</p><p>要获得特定 Lock 实例的Condition 实例，调用该 Lock 对象的 newCondition() 方法即可。</p><blockquote><p>Condition 类提供了如下三个方法：</p><p>await()：让当前线程进入等待状态，直到其他线程调用该 Condition 的 signal() 方法或 signalAll() 方法来唤醒该线程。</p><p>signal()：唤醒在此 Condition 对象上等待的单个线程。如果有多个，则会随机唤醒一个。</p><p>signalAll()：唤醒在此 Condition 对象上等待的所有线程。</p></blockquote><p>例：经典问题：三个线程依次打印10次ABC，代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Print</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionA = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionB = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition conditionC = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> String type = <span class="string">&quot;A&quot;</span>; <span class="comment">//内部状态</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 方法的基本要求为：</span></span><br><span class="line"><span class="comment">     * 1、该方法必须为原子的。</span></span><br><span class="line"><span class="comment">     * 2、当前状态必须满足条件。若不满足，则等待；满足，则执行业务代码。</span></span><br><span class="line"><span class="comment">     * 3、业务执行完毕后，修改状态，并唤醒指定条件下的线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//锁，保证了线程安全。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (type != <span class="string">&quot;A&quot;</span>) &#123; <span class="comment">//type不为A，</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionA.await(); <span class="comment">//将当前线程阻塞于conditionA对象上，将被阻塞。</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//type为A，则执行。</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在打印A&quot;</span>);</span><br><span class="line">            type = <span class="string">&quot;B&quot;</span>; <span class="comment">//将type设置为B。</span></span><br><span class="line">            conditionB.signal(); <span class="comment">//唤醒在等待conditionB对象上的一个线程。将信号传递出去。</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (type != <span class="string">&quot;B&quot;</span>) &#123; <span class="comment">//type不为B，</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionB.await(); <span class="comment">//将当前线程阻塞于conditionB对象上，将被阻塞。</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//type为B，则执行。</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在打印B&quot;</span>);</span><br><span class="line">            type = <span class="string">&quot;C&quot;</span>; <span class="comment">//将type设置为C。</span></span><br><span class="line">            conditionC.signal(); <span class="comment">//唤醒B</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock(); <span class="comment">//锁</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (type != <span class="string">&quot;C&quot;</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conditionC.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 正在打印C&quot;</span>);</span><br><span class="line">            type = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">            conditionA.signal();    <span class="comment">//唤醒A</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock(); <span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Business business = <span class="keyword">new</span> Business();<span class="comment">//业务对象。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程1号，打印10次A。</span></span><br><span class="line">        Thread ta = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                    business.printA();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程2号，打印10次B。</span></span><br><span class="line">        Thread tb = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                    business.printB();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程3号，打印10次C。</span></span><br><span class="line">        Thread tc = <span class="keyword">new</span> Thread(()-&gt; &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                    business.printC();</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行3条线程。</span></span><br><span class="line">        ta.start();</span><br><span class="line">        tb.start();</span><br><span class="line">        tc.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-阻塞队列-BlockingQueue"><a href="#5-3-阻塞队列-BlockingQueue" class="headerlink" title="5.3 阻塞队列 BlockingQueue"></a>5.3 阻塞队列 BlockingQueue</h3><p>Java 5 提供了一个 BlockingQueue 接口，作为线程同步的工具。</p><p>BlockingQueue 具有一个特征：<strong>当生产者线程试图向 BlockingQueue 中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从 BlockingQueue 中取出元素时，如果该队列为空，则该线程被阻塞。</strong></p><p>程序的两个线程通过交替向 BlockingQueue 中放入元素、取出元素，即可很好地控制线程的通信。</p><blockquote><p>  BlockingQueue 提供了如下两个支持阻塞的方法：</p><p>  put(E e)：尝试把 E 元素插入 BlockingQueue 尾部，如果该队列已满，则阻塞该线程。</p><p>  take()：尝试从 BlockingQueue 的头部取出元素，如果该队列的元素已空，则阻塞该线程。</p></blockquote><p>代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Excption</span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个长度为 2 的阻塞队列</span></span><br><span class="line">    BlockingQueue&lt;String&gt; bq = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    bq.put(<span class="string">&quot;Java&quot;</span>);    <span class="comment">// 将 &quot;Java&quot; 放入 bq</span></span><br><span class="line">    bq.put(<span class="string">&quot;Spring&quot;</span>); <span class="comment">// 将 &quot;Spring&quot; 放入 bq</span></span><br><span class="line">    bq.put(<span class="string">&quot;JDBC&quot;</span>);    <span class="comment">// 阻塞线程（且 &quot;JDBC&quot; 不会被放入）</span></span><br><span class="line">    Stirng str = bq.take(); <span class="comment">// &quot;Java&quot; 被取出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-线程池"><a href="#6-线程池" class="headerlink" title="6. 线程池"></a>6. 线程池</h2><p>系统启动一个新线程的成本是比较高的，因为涉及与操作系统交互。使用线程池可以很好地提高性能，尤其是当程序需要创建大量生存期很短的线程时，更应该考虑线程池。</p><p>与数据库连接池相类似，<strong>线程池在系统启动时即创建大量空闲的线程，程序将一个 Runnable 对象或 Callable 对象传给线程池，线程池就会启动一个线程来执行他们的 run() 或 call() 方法，当 run() 或 call() 方法执行结束后，该线程不会死亡，而是再次返回线程池中成为空闲状态。</strong></p><h3 id="6-1-四种常见的线程池"><a href="#6-1-四种常见的线程池" class="headerlink" title="6.1 四种常见的线程池"></a>6.1 四种常见的线程池</h3><ol><li><strong>Executors.newCacheThreadPool()：</strong>可缓存线程池，先查看池中有没有以前建立的线程，如果有，就直接使用。如果没有，就建一个新的线程加入池中，缓存型池子通常用于执行一些生存期很短的异步型任务；</li><li><strong>Executors.newFixedThreadPool(int n)：</strong>创建一个可重用的、固定线程数的线程池；</li><li><strong>Executors.newSingleThreadExecutor()：</strong>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li><li><strong>Executors.newScheduledThreadPool(int corePoolSize)：</strong>创建一个指定线程数的线程池，它可以在指定延迟时间间隔后再执行线程任务；</li></ol><blockquote><p>  上面的<strong>前三个方法返回一个 ExecutorService 对象</strong>，该对象代表一个线程池，可以执行 Runnable 对象或 Callable 对象所代表的线程；而<strong>第 4 个方法返回一个 ScheduledExecutorService 对象</strong>，它是 ExecutorService 对象的子类，可以在指定延迟后执行线程任务。</p></blockquote><p>前三个方法的代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个可重用的、数量为6的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">6</span>);</span><br><span class="line">        <span class="comment">// 创建一个可缓存线程池</span></span><br><span class="line"><span class="comment">//        ExecutorService pool = Executors.newCachedThreadPool();</span></span><br><span class="line">        <span class="comment">//创建一个只有单线程的线程池</span></span><br><span class="line"><span class="comment">//        ExecutorService pool = Executors.newSingleThreadExecutor();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Runnable 对象</span></span><br><span class="line">        Runnable target = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ExecutorService对象的 submit() 方法接收一个 Runnable 对象交给线程池，执行其 run() 方法；</span></span><br><span class="line">        <span class="comment">// 也可以接收 Callable 对象，执行其 call() 方法</span></span><br><span class="line">        pool.submit(target);</span><br><span class="line">        pool.submit(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池。会在全部线程任务执行完成后再关闭</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newScheduledThreadPool(int corePoolSize) 方法的代码例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个数量为3的 ScheduledExecutorService 线程池</span></span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Runnable 对象</span></span><br><span class="line">        Runnable target = () -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">21</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">&quot; &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ScheduledExecutorService 对象的 schedule() 方法可接收 Runnable 或 Callable 对象</span></span><br><span class="line">        <span class="comment">// 并指定延迟时间。以下代码会在 2 秒后再执行所以线程</span></span><br><span class="line">        pool.schedule(target,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">          pool.schedule(target,<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭线程池。会在全部线程任务执行完成后再关闭</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Security认证</title>
      <link href="2020/11/05/security%E5%85%A5%E9%97%A8/"/>
      <url>2020/11/05/security%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>最近写项目涉及到登录认证和授权，一直不太熟，就从网上找了很多用户登录认证和授权的资料。几天下拉也算是会用了一些，在这里记录一些简单的例子。</p><p>Spring Security是Spring 家族中的一个安全管理框架，它的出现还要早于Spring Boot，只是使用的不多，安全管理这个领域，一直是 Shiro 争霸。</p><p>相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。</p><p>但是！！！<strong>自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。</strong></p><p>Spring Security的简单介绍这里不多说，以项目代码为主：</p><h2 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1. 代码实现"></a>1. 代码实现</h2><p><strong>第一步，引入Security依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>       </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第二步，实体类实现UserDetails接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现了UserDetails接口，只留必需的属性，也可添加自己需要的属性</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> itle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">UserDetails</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;    <span class="comment">//登录用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password;    <span class="comment">//登录密码</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;? extends GrantedAuthority&gt; authorities;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthorities</span><span class="params">(Collection&lt;? extends GrantedAuthority&gt; authorities)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authorities = authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//账户是否未过期</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//账户是否未锁定</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//密码是否未过期</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//账户是否存在</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第三步，配置适配器WebSecurityConfigurerAdapter</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.itle.security.service.impl.MyPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> com.itle.security.service.impl.UserDetailsServiceImpl;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.BadCredentialsException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.DisabledException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.dao.DaoAuthenticationProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.HttpSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.builders.WebSecurity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *参考网址：</span></span><br><span class="line"><span class="comment"> * https://www.cnblogs.com/aismvy/p/12877713.html</span></span><br><span class="line"><span class="comment"> * https://www.jianshu.com/p/650a497b3a40</span></span><br><span class="line"><span class="comment"> *Security配置文件，项目启动时就加载了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> itle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsServiceImpl userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyPasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        http.authenticationProvider(authenticationProvider())</span><br><span class="line">                .httpBasic()</span><br><span class="line">                <span class="comment">//未登录时，进行json格式的提示，很喜欢这种写法，不用单独写一个又一个的类</span></span><br><span class="line">                .authenticationEntryPoint((request, response, authException) -&gt; &#123;</span><br><span class="line">                    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, <span class="number">403</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;未登录&quot;</span>);</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//请求认证管理</span></span><br><span class="line">                .and()</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .anyRequest().authenticated() <span class="comment">//必须授权才能范围 //其他的路径都是登录后即可访问</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//from表单登录设置</span></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin()</span><br><span class="line">                .loginProcessingUrl(<span class="string">&quot;/login&quot;</span>)   <span class="comment">//自定义处理认证的url    默认为/login</span></span><br><span class="line">                .usernameParameter(<span class="string">&quot;username&quot;</span>)  <span class="comment">//设置form表单中用户名对应的name参数  默认为username</span></span><br><span class="line">                .passwordParameter(<span class="string">&quot;password&quot;</span>)  <span class="comment">//设置form表单中密码对应的name参数 默认为password</span></span><br><span class="line">                .permitAll()        <span class="comment">//对于需要所有用户都可以访问的界面 或者url进行设置</span></span><br><span class="line">                <span class="comment">//登录失败，返回json</span></span><br><span class="line">                .failureHandler((request, response, ex) -&gt; &#123;</span><br><span class="line">                    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, <span class="number">401</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> UsernameNotFoundException || ex <span class="keyword">instanceof</span> BadCredentialsException) &#123;</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;用户名或密码错误&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> DisabledException) &#123;</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;账户被禁用&quot;</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录失败!&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                <span class="comment">//登录成功，返回json</span></span><br><span class="line">                .successHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;data&quot;</span>, authentication);</span><br><span class="line">                    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有权限，返回json</span></span><br><span class="line">        http.exceptionHandling()</span><br><span class="line">                .accessDeniedHandler((request, response, ex) -&gt; &#123;</span><br><span class="line">                    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    response.setStatus(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, <span class="number">403</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;权限不足&quot;</span>);</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//退出成功，返回json</span></span><br><span class="line">        http.logout()</span><br><span class="line">                .logoutSuccessHandler((request, response, authentication) -&gt; &#123;</span><br><span class="line">                    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    map.put(<span class="string">&quot;code&quot;</span>, <span class="number">200</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;message&quot;</span>, <span class="string">&quot;退出成功&quot;</span>);</span><br><span class="line">                    map.put(<span class="string">&quot;data&quot;</span>, authentication);</span><br><span class="line">                    response.setContentType(<span class="string">&quot;application/json;charset=utf-8&quot;</span>);</span><br><span class="line">                    PrintWriter out = response.getWriter();</span><br><span class="line">                    out.write(objectMapper.writeValueAsString(map));</span><br><span class="line">                    out.flush();</span><br><span class="line">                    out.close();</span><br><span class="line">                &#125;)</span><br><span class="line">                .permitAll();</span><br><span class="line">        <span class="comment">//开启跨域访问</span></span><br><span class="line">        http.cors()</span><br><span class="line">                .and()</span><br><span class="line">                <span class="comment">//开启模拟请求，比如API POST测试工具的测试，不开启时，API POST为报403错误</span></span><br><span class="line">                .csrf().disable();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对于在header里面增加token等类似情况，放行所有OPTIONS请求。</span></span><br><span class="line"><span class="comment">//        web.ignoring().antMatchers(HttpMethod.OPTIONS, &quot;/**&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AuthenticationProvider <span class="title">authenticationProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DaoAuthenticationProvider authenticationProvider = <span class="keyword">new</span> DaoAuthenticationProvider();</span><br><span class="line">        <span class="comment">//对默认的UserDetailsService进行覆盖</span></span><br><span class="line">        authenticationProvider.setUserDetailsService(userDetailsService);</span><br><span class="line">        authenticationProvider.setPasswordEncoder(passwordEncoder);</span><br><span class="line">        <span class="keyword">return</span> authenticationProvider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>第四步，实现UserDetailsService接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itle.security.bean.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 自定义登录认证类，实现了UserDetailsService接口，用户登录时调用的第一类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> itle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登陆验证时，通过username获取用户的所有权限信息</span></span><br><span class="line"><span class="comment">     * 并返回UserDetails放到spring的全局缓存SecurityContextHolder中，以供授权器使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 在这里可以自己调用数据库，对username进行查询，看看在数据库中是否存在</span></span><br><span class="line"><span class="comment">         * 不存在可以返回一个空User()对象，在后期的密码比对过程中一样会验证失败</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(s);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);    <span class="comment">//这里写死密码为123456</span></span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第五步，实现PasswordEncoder接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *自定义的密码加密方法，实现了PasswordEncoder接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> itle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPasswordEncoder</span> <span class="keyword">implements</span> <span class="title">PasswordEncoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">encode</span><span class="params">(CharSequence charSequence)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//加密方法可以根据自己的需要修改</span></span><br><span class="line">        <span class="keyword">return</span> charSequence.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(CharSequence charSequence, String s)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//加密解密还要写专门的工具类，所以这里没有加密，只是简单的对比</span></span><br><span class="line">        <span class="keyword">return</span> encode(charSequence).equals(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  说明：这个类主要是对密码加密的处理，以及用户传递过来的密码（即参数CharSequence）和数据库密码（UserDetailsService中的密码）进行比对。</p><p>  <strong>Security规定密码必须要进行加密。</strong></p></blockquote><h2 id="2-简单测试"><a href="#2-简单测试" class="headerlink" title="2. 简单测试"></a>2. 简单测试</h2><p>以上简单的一个登陆认证已经写完了，接下来需要进行测试。</p><p><strong>测试一，未登录直接访问index，浏览器输入 localhost:8055/index ，页面直接重定向到默认的login页面，说明我们配置.authorizeRequests().anyRequest().authenticated() 成功。</strong></p><p><img src="/images/javaEE/security01.jpg" class="lazyload" data-srcset="/images/javaEE/security01.jpg" srcset="data:image/png;base64,666"></p><blockquote><p>  【注】：这是Spring Security 自带的默认登陆页面</p></blockquote><p><strong>测试二，登陆login后，返回登陆成功结果，测试成功</strong></p><p><img src="/images/javaEE/security02.jpg" class="lazyload" data-srcset="/images/javaEE/security02.jpg" srcset="data:image/png;base64,666"></p><blockquote><p>  我们写自定义认证的时候规定，登陆密码为123456</p></blockquote><p><strong>测试三，故意输错密码，返回提示信息 ，测试成功</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">401</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;用户名或密码错误&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>测试四，访问 localhost:8055/logout 登出操作，返回提示信息，测试成功</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;code&quot;</span>:<span class="number">200</span>,<span class="string">&quot;data&quot;</span>:<span class="literal">null</span>,<span class="string">&quot;message&quot;</span>:<span class="string">&quot;退出成功&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="3-跨域问题"><a href="#3-跨域问题" class="headerlink" title="3. 跨域问题"></a>3. 跨域问题</h2><p>我们都知道，目前的项目是前后端分离的，所以我用VUE项目通过 axios 请求，于是引出了跨域问题。</p><p><img src="/images/javaEE/security03.jpg" class="lazyload" data-srcset="/images/javaEE/security03.jpg" srcset="data:image/png;base64,666"></p><p><strong>要解决跨域问题，通过测试我得出一个完全解决的办法：</strong></p><p>自定义配置类即可解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> itle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/10/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> CorsConfiguration <span class="title">buildConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CorsConfiguration corsConfiguration = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        corsConfiguration.addAllowedOrigin(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addAllowedMethod(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        corsConfiguration.addExposedHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> corsConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        source.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, buildConfig());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                .allowedOrigins(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  加上这段配置后，需要跨域的Controller不需要加@CrossOrigin注解也可实现跨域，跨域问题完美解决！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Security </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引优化分析</title>
      <link href="2020/10/25/mysql%E9%AB%98%E7%BA%A7/"/>
      <url>2020/10/25/mysql%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="1-索引优化分析"><a href="#1-索引优化分析" class="headerlink" title="1. 索引优化分析"></a>1. 索引优化分析</h2><h3 id="1-1-索引的概念"><a href="#1-1-索引的概念" class="headerlink" title="1.1 索引的概念"></a>1.1 索引的概念</h3><p>MySQL 官方对索引的定义为：索引（Index）是帮助MySQL 高效获取数据的数据结构。可以得到索引的本质：<strong>索引是数据结构。可以简单理解为排好序的快速查找数据结构。</strong></p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p><img src="/images/mysql/1601024115(1).jpg" class="lazyload" data-srcset="/images/mysql/1601024115(1).jpg" srcset="data:image/png;base64,666"><p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p><p>一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</p><h3 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h3><p><strong>优点：</strong></p><ul><li>提高数据检索的效率，降低数据库的IO成本。</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗。</li></ul><p><strong>缺点：</strong></p><ul><li>虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li><li>实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要<strong>占用空间</strong>的。</li></ul><h2 id="2-MySQL索引的数据结构"><a href="#2-MySQL索引的数据结构" class="headerlink" title="2. MySQL索引的数据结构"></a>2. MySQL索引的数据结构</h2><p><strong>B树和B+树</strong></p><blockquote><p>  【小细节】 </p><p>  B树就是B-tree，’ - ‘ 只是一个符号；B+树其实是B+-tree</p><p>  B树是一棵平衡树(AVL树)，而平衡树每次在进行增删改时都会失去平衡，因此就要就要通过旋转来保持平衡，而旋转是非常耗时的，由此我们可以知道AVL树适合用于插入删除次数比较少，但查找多的情况。</p></blockquote><h3 id="2-1-B树"><a href="#2-1-B树" class="headerlink" title="2.1 B树"></a>2.1 B树</h3><p><strong>B-Tree的性质</strong></p><p>1、定义任意非叶子结点最多只有M个儿子，且M&gt;2；<br>2、根结点的儿子数为[2, M]；<br>3、除根结点以外的非叶子结点的儿子数为[M/2, M]；<br>4、每个结点存放至少M/2-1（取上整）和至多M-1个关键字；（至少2个关键字）<br>5、非叶子结点的关键字个数=指向儿子的指针个数-1；<br>6、非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；<br>7、非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[M]指向关键字大于K[M-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；<br>8、所有叶子结点位于同一层； </p><p><strong>B树结构如下图：</strong></p><p><img src="/images/mysql/1603865296.png" class="lazyload" data-srcset="/images/mysql/1603865296.png" srcset="data:image/png;base64,666"></p><p>【介绍】</p><blockquote><p>  系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来。</p><p>  InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。</p><p>  InnoDB在把磁盘数据读入到内存时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。</p></blockquote><p>【初始化介绍】</p><blockquote><p>  一颗b 树，浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示）；</p><p>  如磁盘块1 包含数据项17 和35，包含指针P1、P2、P3，P1 表示小于17 的磁盘块，</p><p>  P2 表示在17 和35 之间的磁盘块，P3 表示大于35 的磁盘块。</p><p>  真实的数据存在于叶子节点即3、5、9、10、13、15、28、29、36、60、75、79、90、99。</p><p>  非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如17、35 并不真实存在于数据表中。如磁盘块1 包含数据项17 和35，包含指针P1、P2、P3</p></blockquote><p>【查找过程】</p><blockquote><p>  如果要查找数据项29，那么首先会把磁盘块1 由磁盘加载到内存，此时发生一次IO，在内存中用二分查找确定29在17 和35 之间，锁定磁盘块1 的P2 指针，内存时间因为非常短（相比磁盘的IO）可以忽略不计，通过磁盘块1的P2 指针的磁盘地址把磁盘块3 由磁盘加载到内存，发生第二次IO，29 在26 和30 之间，锁定磁盘块3 的P2 指针，通过指针加载磁盘块8 到内存，发生第三次IO，同时内存中做二分查找找到29，结束查询，总计三次IO。</p><p>  <strong>真实的情况是，3 层的b+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO，那么总共需要百万次的IO，显然成本非常非常高。</strong></p></blockquote><h3 id="2-2-B-Tree"><a href="#2-2-B-Tree" class="headerlink" title="2.2 B+Tree"></a>2.2 B+Tree</h3><p><strong>B+Tree是在B-Tree基础上的一种优化</strong>，使其更适合实现外存储索引结构，<strong>InnoDB存储引擎就是用B+Tree实现其索引结构</strong>。</p><p>B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p><p><img src="/images/mysql/1603952458.png" class="lazyload" data-srcset="/images/mysql/1603952458.png" srcset="data:image/png;base64,666"></p><p><strong>B+Tree相对于B-Tree有几点不同：</strong></p><ol><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ol><h3 id="2-3-应用"><a href="#2-3-应用" class="headerlink" title="2.3 应用"></a>2.3 应用</h3><p>B和B+树主要用在文件系统以及数据库做索引，比如MySQL；</p><blockquote><p>  【B/B+树性能】</p><p>  在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，<strong>而在实际应用中却是B+树的性能要好些</strong>。因为B+树的非叶子节点不存放实际的数据，这样每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是<strong>一次磁盘访问的时间相当于成百上千次内存比较的时间</strong>，因此实际中B+树的性能可能还会好些，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。</p></blockquote><p><strong>为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？</strong></p><p><strong>1、B+树的磁盘读写代价更低</strong></p><p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO 读写次数也就降低了。</p><p><strong>2、B+树的查询效率更加稳定</strong></p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><hr><h2 id="3-聚簇索引与非聚簇索引"><a href="#3-聚簇索引与非聚簇索引" class="headerlink" title="3. 聚簇索引与非聚簇索引"></a>3. 聚簇索引与非聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。术语‘聚簇’表示数据行和相邻的键值聚簇的存储在一起。</p><p>如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。</p><p><img src="/images/mysql/1603955597.jpg" class="lazyload" data-srcset="/images/mysql/1603955597.jpg" srcset="data:image/png;base64,666"></p><p>当表中有聚簇索引时，它的数据实际上存储在索引的叶子页中（叶子页中包含了行的全部数据）。而没有聚簇索引时B+Tree叶子页存放的是指向数据的指针。</p><blockquote><p>   <strong>（页是mysql存储引擎最小的存储单元，InnoDB每个页默认大小为16k）可以理解为 有聚簇索引时，数据和对应的叶子页在同一页中，没有聚簇索引时，叶子页和对应的数据不在同一页中。</strong></p></blockquote><p><strong>聚簇索引的好处：</strong></p><ul><li>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不用从多个数据块中提取数据，所以节省了大量的io 操作。</li><li>数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从举措索引中获取数据通常比非聚簇索引查找更快。</li></ul><p><strong>聚簇索引的限制：</strong></p><ul><li>对于mysql 数据库目前<strong>只有innodb 数据引擎支持聚簇索引</strong>，而Myisam 并不支持聚簇索引。</li><li>由于数据物理存储排序方式只能有一种，所以<strong>每个Mysql 的表只能有一个聚簇索引</strong>。一般情况下就是该表的主键。</li><li>为了充分利用聚簇索引的聚簇的特性，所以innodb <strong>表的主键列尽量选用有序的顺序id</strong>(如AUTO_INCREMENT自增列) 而不建议用无序的id，比如uuid 这种。</li></ul><blockquote><p>  【InnoDB和MyISAM存储引擎】</p><p>  <strong>InnoDB存储引擎通过主键聚集数据(聚簇索引)。</strong>如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有唯一索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。</p><p>  <strong>MyISAM中主键索引和其他索引 都指向物理行 (非聚簇索引)</strong></p></blockquote><hr><h2 id="4-MySQL索引分类"><a href="#4-MySQL索引分类" class="headerlink" title="4. MySQL索引分类"></a>4. MySQL索引分类</h2><p><strong>1. 索引的分类</strong></p><table><thead><tr><th>索引种类</th><th>含义</th></tr></thead><tbody><tr><td>单值索引</td><td>即一个索引只包含单个列，一个表可以有多个单列索引</td></tr><tr><td>唯一索引</td><td>索引列的值必须唯一，但允许有空值</td></tr><tr><td>主键索引</td><td>设定为主键后数据库会自动建立索引，innodb为聚簇索引</td></tr><tr><td>复合索引</td><td>即一个索引包含多个列</td></tr></tbody></table><p><strong>2. 语法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE customer (</span><br><span class="line">  id INT(10) UNSIGNED AUTO_INCREMENT ,</span><br><span class="line">  customer_no VARCHAR(200),</span><br><span class="line">  customer_name VARCHAR(200),</span><br><span class="line">  </span><br><span class="line">  PRIMARY KEY(id),    #设定主键，自动建立主键索引</span><br><span class="line">  KEY (customer_name),    #单值索引</span><br><span class="line">  UNIQUE (customer_no),    #唯一索引</span><br><span class="line">  KEY (customer_no,customer_name)    #复合索引</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>单独建单值索引：CREATE INDEX idx_customer_name ON customer(customer_name);</p><p>单独建唯一索引：CREATE UNIQUE INDEX idx_customer_no ON customer(customer_no);</p><p>单独建复合索引：CREATE INDEX idx_no_name ON customer(customer_no,customer_name);</p><hr><h2 id="5-索引创建的时机"><a href="#5-索引创建的时机" class="headerlink" title="5. 索引创建的时机"></a>5. 索引创建的时机</h2><h3 id="5-1-适合创建索引的情况"><a href="#5-1-适合创建索引的情况" class="headerlink" title="5.1 适合创建索引的情况"></a>5.1 适合创建索引的情况</h3><ul><li>主键自动建立唯一索引；</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其它表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题， 组合索引性价比更高</li><li>查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ul><h3 id="5-2-不适合创建索引的情况"><a href="#5-2-不适合创建索引的情况" class="headerlink" title="5.2 不适合创建索引的情况"></a>5.2 不适合创建索引的情况</h3><ul><li>表记录太少</li><li>经常增删改的表或者字段</li><li>Where 条件里用不到的字段不创建索引</li><li>过滤性不好的不适合建索引</li></ul>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
          <category> mysql高级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC笔记</title>
      <link href="2020/10/23/JDBC/"/>
      <url>2020/10/23/JDBC/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>JDBC的全称是Java Database Connectivity，即Java数据库连接。使用JDBC对数据库进行操作，只需要三个基本工作：</p><ul><li>建立与数据库的连接</li><li>执行SQL语句</li><li>获得SQL语句的执行结果</li></ul><h2 id="1-JDBC-编程步骤"><a href="#1-JDBC-编程步骤" class="headerlink" title="1. JDBC 编程步骤"></a>1. JDBC 编程步骤</h2><p><strong>1、加载数据库驱动</strong></p><p>通常使用Class类的forName()静态方法来加载驱动。（这是一种反射的方式）</p><p>不同数据库使用不同的驱动，加载MySQL的驱动采用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载MySQL的驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br></pre></td></tr></table></figure><p>而加载Oracle 的驱动则如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载Oracle的驱动</span></span><br><span class="line">Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>2、通过DriverManager获取数据库连接。DriverManager提供了如下方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取数据库连接</span></span><br><span class="line">DriverManager.getConnection(String url, String username, String password);</span><br></pre></td></tr></table></figure><p>其中，username 是数据库的连接账号，password是数据库的连接密码</p><p>而url是数据库的连接URL，</p>]]></content>
      
      
      <categories>
          
          <category> Java核心 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jdbc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC工作原理</title>
      <link href="2020/10/23/springMVC/"/>
      <url>2020/10/23/springMVC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-SpringMVC的工作原理"><a href="#1-SpringMVC的工作原理" class="headerlink" title="1. SpringMVC的工作原理"></a>1. SpringMVC的工作原理</h2><div class="img-wrap"><div class="img-bg"><img class="img" src="images/javaEE/springmvc.jpg" class="lazyload" data-srcset="images/javaEE/springmvc.jpg" srcset="data:image/png;base64,666" alt="springmvc.jpg"/></div><span class="image-caption">springmvc.jpg</span></div><blockquote><p>  1、  用户发送请求至前端控制器DispatcherServlet。</p><p>  2、  DispatcherServlet收到请求调用HandlerMapping处理器映射器。</p><p>  3、  处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</p><p>  4、  DispatcherServlet调用HandlerAdapter处理器适配器。</p><p>  5、  HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。</p><p>  6、  Controller执行完成返回ModelAndView。</p><p>  7、  HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</p><p>  8、  DispatcherServlet将ModelAndView传给ViewReslover视图解析器。</p><p>  9、  ViewReslover解析后返回具体View。</p><p>  10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。</p><p>  11、 DispatcherServlet响应用户。</p></blockquote><h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h2><p>@RequestMapping可以接收REST风格的URL，常用的有如下几种:</p><ul><li>/user/*/show：匹配 /user/aaa/show、 /user/bbb/show 等URL</li><li>/user/**/show：匹配 /user/aaa/show、 /user/123/bbb/show 等URL</li><li>/user/{userId}：匹配 /user/123、 /user/234 等URL</li><li>/user/**/{userId}：匹配 /user/aaa/abc/123、 /user/aaa/234 等URL</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标准的URL格式，只匹配/user/cresteUser</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/user/cresteUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">cresteUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;index&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用占位符，URL中的&#123;xxx&#125;占位符可以通过@PathVariable(&quot;xxx&quot;)绑定到方法的参数中</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/user/&#123;userId&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">(<span class="meta">@PathVariable(&quot;userId&quot;)</span>String id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java框架 </category>
          
          <category> SpringMVC </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE-路由配置及跳转方式</title>
      <link href="2020/10/14/vue%E8%B7%AF%E7%94%B1/"/>
      <url>2020/10/14/vue%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在vue中，页面的他跳转和卡片切换一般会用到路由router，具体不多说，主要记录一下路由的配置和几种常用的跳转方式</p><h3 id="路由配置重定向-index-js-："><a href="#路由配置重定向-index-js-：" class="headerlink" title="路由配置重定向 index.js ："></a>路由配置重定向 index.js ：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Page2 <span class="keyword">from</span> <span class="string">&#x27;../components/Page2&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Chil1 <span class="keyword">from</span> <span class="string">&#x27;../components/Chil1&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Chil2 <span class="keyword">from</span> <span class="string">&#x27;../components/Chil2&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;Home&#x27;</span>,    <span class="comment">//可以不用name字段   但有时需要用到name匹配</span></span><br><span class="line">      component: Home</span><br><span class="line">    &#125; ,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/page2&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;Page2&#x27;</span>,</span><br><span class="line">      component: Page2,</span><br><span class="line">      children:[        <span class="comment">//页内切换卡片</span></span><br><span class="line">                &#123;</span><br><span class="line">                   path: <span class="string">&#x27;/chil1&#x27;</span>,    <span class="comment">// 带‘/’ 表示根路径</span></span><br><span class="line">                   name: <span class="string">&#x27;Chil1&#x27;</span>,</span><br><span class="line">                   component: Chil1</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    path: <span class="string">&#x27;chil2&#x27;</span>,    <span class="comment">// 不带‘/’ 表示访问路径为/page2/chil2</span></span><br><span class="line">                    name: <span class="string">&#x27;Chil2&#x27;</span>,</span><br><span class="line">                    component: Chil2</span><br><span class="line">                &#125;</span><br><span class="line">            ]     </span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/&#x27;</span>,    <span class="comment">//匹配根路径 用于默认打开的页面</span></span><br><span class="line">      name: <span class="string">&#x27;index&#x27;</span>,</span><br><span class="line">      redirect: <span class="string">&#x27;/home&#x27;</span>  <span class="comment">//redirect重定向到Home组件</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]  </span><br><span class="line">&#125;）</span><br></pre></td></tr></table></figure><h3 id="路由跳转的几种方式"><a href="#路由跳转的几种方式" class="headerlink" title="路由跳转的几种方式"></a>路由跳转的几种方式</h3><p><strong>一、使用标签路由 router-link</strong> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、不传参</span><br><span class="line"></span><br><span class="line">　   &lt;router-link :to=<span class="string">&quot;&#123;name:&#x27;Home&#x27;&#125;&quot;</span>&gt; </span><br><span class="line">　   &lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;/home&#x27;&#125;&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、传参</span><br><span class="line"></span><br><span class="line">　　&lt;router-link :to=<span class="string">&quot;&#123;name:&#x27;Home&#x27;, params: &#123;id:1&#125;&#125;&quot;</span>&gt;</span><br><span class="line">　　&lt;router-link :to=<span class="string">&quot;&#123;path:&#x27;/home&#x27;, params: &#123;id:1&#125;&#125;&quot;</span>&gt; </span><br><span class="line">　　<span class="comment">// params传参数</span></span><br><span class="line">　　<span class="comment">// 路由配置 path: &quot;/home/:id&quot;</span></span><br><span class="line">　　<span class="comment">// 不配置path ,第一次可请求,刷新页面id会消失</span></span><br><span class="line">　　<span class="comment">// 配置path,刷新页面id会保留</span></span><br><span class="line">　　<span class="comment">// html 取参 $route.params.id</span></span><br><span class="line">　　<span class="comment">// script 取参 this.$route.params.id</span></span><br><span class="line"></span><br><span class="line">　　&lt;router-link :to=<span class="string">&quot;&#123;name:&#x27;Home&#x27;, query: &#123;id:1&#125;&#125;&quot;</span>&gt;</span><br><span class="line">　　<span class="comment">// query传参数 (类似get,页面url后面会显示参数)</span></span><br><span class="line">　　<span class="comment">// 路由可不配置</span></span><br><span class="line">　　<span class="comment">// html 取参 $route.query.id</span></span><br><span class="line">　　<span class="comment">// script 取参 this.$route.query.id</span></span><br></pre></td></tr></table></figure><p><strong>二、编程式路由 this.$router.push()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、不传参</span><br><span class="line">　　<span class="built_in">this</span>.$router.push(<span class="string">&#x27;/home&#x27;</span>)</span><br><span class="line">　　<span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>:<span class="string">&#x27;Home&#x27;</span>&#125;)</span><br><span class="line">　　<span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、传参</span><br><span class="line">　　<span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>:<span class="string">&#x27;home&#x27;</span>,<span class="attr">params</span>: &#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>&#125;&#125;)  <span class="comment">// 只能用 name</span></span><br><span class="line">　　<span class="comment">// params传参数</span></span><br><span class="line">　　<span class="comment">// 路由配置 path: &quot;/home/:id&quot;</span></span><br><span class="line">　　<span class="comment">// 不配置path ,第一次可请求,刷新页面id会消失</span></span><br><span class="line">　　<span class="comment">// 配置path,刷新页面id会保留</span></span><br><span class="line">　　<span class="comment">// html 取参 $route.params.id</span></span><br><span class="line">　　<span class="comment">// script 取参 this.$route.params.id</span></span><br><span class="line"></span><br><span class="line">   <span class="built_in">this</span>.$router.push(&#123;<span class="attr">name</span>:<span class="string">&#x27;Home&#x27;</span>,<span class="attr">query</span>: &#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>&#125;&#125;)</span><br><span class="line">   <span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>:<span class="string">&#x27;/home&#x27;</span>,<span class="attr">query</span>: &#123;<span class="attr">id</span>:<span class="string">&#x27;1&#x27;</span>&#125;&#125;)</span><br><span class="line">　　<span class="comment">// query传参数 (类似get,页面url后面会显示参数)</span></span><br><span class="line">　　<span class="comment">// 路由可不配置</span></span><br><span class="line">　　<span class="comment">// html 取参 $route.query.id</span></span><br><span class="line">　　<span class="comment">// script 取参 this.$route.query.id</span></span><br></pre></td></tr></table></figure><blockquote><p>  在axios中使用 this.$router.push() 时，如果使用function会取不到this而报错，而要使用箭头函数</p><p>  如下：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">onSubmit() &#123;</span><br><span class="line">      axios.post(<span class="string">&#x27;http://localhost:8022/user/login&#x27;</span>,qs.stringify(<span class="built_in">this</span>.user))</span><br><span class="line">      .then(<span class="function">(<span class="params">response</span>)=&gt;</span>&#123;    <span class="comment">//正确；    使用function(response）&#123;&#125;会报错。。。我也不知为啥。。</span></span><br><span class="line">        alert(response.data.msg);</span><br><span class="line">        <span class="keyword">if</span> (response.data.url)&#123;</span><br><span class="line">          <span class="built_in">this</span>.$router.push(&#123;<span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> alert(error))</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
          <category> router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE </tag>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="2020/10/14/%E6%B5%8B%E8%AF%95/"/>
      <url>2020/10/14/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>测试</p>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
          <category> router </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE </tag>
            
            <tag> router </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VUE使用axios请求后端数据</title>
      <link href="2020/10/12/axios/"/>
      <url>2020/10/12/axios/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>最近学习vue尝试使用axios请求后端数据，发现了一大堆问题，后端接收不到请求的数据。查了资料之后，在这里总结记录一下。</p><p>先说一下常用的几种请求方式和模板：</p><h3 id="Get方式"><a href="#Get方式" class="headerlink" title="Get方式"></a>Get方式</h3><p>GET 方法传递参数格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    axios.get(<span class="string">&#x27;http://localhost:8022/user/login&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span>    <span class="comment">//参数ID</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;    <span class="comment">//请求成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    alert(response.data.msg);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;        <span class="comment">//请求失败</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="Post方式"><a href="#Post方式" class="headerlink" title="Post方式"></a>Post方式</h3><p>POST 方法传递参数格式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    axios.post(<span class="string">&#x27;http://localhost:8022/user/login&#x27;</span>, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: <span class="number">12345</span>    <span class="comment">//参数ID</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;    <span class="comment">//请求成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    alert(response.data.msg);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;        <span class="comment">//请求失败</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="axios-API-方式"><a href="#axios-API-方式" class="headerlink" title="axios API 方式"></a>axios API 方式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type = <span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="comment">//  可以将请求方式、URL、请求/响应格式、请求头等参数进行单独配置</span></span><br><span class="line">    axios(&#123;        <span class="comment">//GET 请求远程图片</span></span><br><span class="line">          method:<span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">         url:<span class="string">&#x27;http://bit.ly/2mTM3nY&#x27;</span>,</span><br><span class="line">          responseType:<span class="string">&#x27;stream&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">      .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">          response.data.pipe(fs.createWriteStream(<span class="string">&#x27;ada_lovelace.jpg&#x27;</span>))</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="axios响应结构"><a href="#axios响应结构" class="headerlink" title="axios响应结构"></a>axios响应结构</h3><p>axios请求的响应包含以下信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// `data` 由服务器提供的响应</span></span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `status`  HTTP 状态码</span></span><br><span class="line">  status: 200,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `statusText` 来自服务器响应的 HTTP 状态信息</span></span><br><span class="line">  statusText: &quot;OK&quot;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `headers` 服务器响应的头</span></span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// `config` 是为请求提供的配置信息</span></span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 then 时，会接收下面这样的响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;/user/12345&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.data);</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">    <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">    <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">    <span class="built_in">console</span>.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="axios配置默认值"><a href="#axios配置默认值" class="headerlink" title="axios配置默认值"></a>axios配置默认值</h3><p>可以指定将被用在各个请求的配置默认值。</p><p>全局的 axios 默认值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">&#x27;https://api.example.com&#x27;</span>;</span><br><span class="line">axios.defaults.headers.common[<span class="string">&#x27;Authorization&#x27;</span>] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="post请求出现的错误"><a href="#post请求出现的错误" class="headerlink" title="post请求出现的错误"></a>post请求出现的错误</h3><p>我们知道在做 post 请求的时候，我们的传参是 <code>data: &#123;...&#125;</code> 或者直接 <code>&#123;...&#125;</code> 的形式传递的。</p><p>在使用时，axios会帮我们 <strong>转换请求数据和响应数据</strong> 以及 <strong>自动转换 JSON 数据</strong></p><p>而在使用post方式请求时，会出现后端接收不到数据的现象</p><p><strong>解决方案一</strong></p><p>【用 URLSearchParams 传递参数】</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> param = <span class="keyword">new</span> URLSearchParams()</span><br><span class="line">param.append(<span class="string">&#x27;username&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">param.append(<span class="string">&#x27;pwd&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line">axios(&#123;</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;/api/lockServer/search&#x27;</span>,</span><br><span class="line">    data: param</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>  需要注意的是： <code>URLSearchParams</code> 不支持所有的浏览器，但是总体的支持情况还是 OK 的，所以优先推荐这种简单直接的解决方案</p></blockquote><hr><p><strong>解决方案二</strong></p><p>【使用qs库】</p><p><code>npm install qs --save</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span>        <span class="comment">//引入qs</span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    <span class="string">&quot;pwd&quot;</span>: <span class="string">&quot;admin&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios(&#123;</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;deviceCode&#x27;</span>: <span class="string">&#x27;A95ZEF1-47B5-AC90BF3&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    url: <span class="string">&#x27;/api/lockServer/search&#x27;</span>,</span><br><span class="line">    data: Qs.stringify(data)    <span class="comment">//使用qs将参数转换为query参数</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>  <em>网上有很多方案说使用</em></p><p>  axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;</p><p>  但是我用的时候不需要，没请求成功的可以试试</p></blockquote><hr><p><strong>解决方案三</strong></p><p>可以通过修改 <code>transformRequest</code> 来达到我们的目的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span></span><br><span class="line">axios(&#123;</span><br><span class="line">    url: <span class="string">&#x27;/api/lockServer/search&#x27;</span>,</span><br><span class="line">    method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">    transformRequest: [<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 对 data 进行任意转换处理</span></span><br><span class="line">        <span class="keyword">return</span> Qs.stringify(data)</span><br><span class="line">    &#125;],</span><br><span class="line">    headers: &#123;</span><br><span class="line">        <span class="string">&#x27;deviceCode&#x27;</span>: <span class="string">&#x27;A95ZEF1-47B5-AC90BF3&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        username: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">        pwd: <span class="string">&#x27;admin&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> VUE </category>
          
          <category> axios </category>
          
      </categories>
      
      
        <tags>
            
            <tag> VUE </tag>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随手记录</title>
      <link href="2020/09/16/%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%A2%98/"/>
      <url>2020/09/16/%E5%B8%B8%E8%A7%81%E7%AC%94%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="js中const，var，let区别与用法"><a href="#js中const，var，let区别与用法" class="headerlink" title="js中const，var，let区别与用法"></a>js中const，var，let区别与用法</h3><p>1.const定义的变量不可以修改，而且必须初始化。</p><p>2.var定义的变量可以修改，如果不初始化会输出undefined，不会报错。</p><p>3.let是块级作用域，函数内部使用let定义后，对函数外部无影响。</p><h3 id="trim函数"><a href="#trim函数" class="headerlink" title="trim函数"></a><strong>trim函数</strong></h3><p>trim()删除文本中除单词间的单个空格之外的所有空格</p><h3 id="window-confirm"><a href="#window-confirm" class="headerlink" title="window.confirm()"></a>window.confirm()</h3><p>window.confirm()方法用于显示一个带有指定消息和确认及取消按钮的对话框。</p><p>如果访问者点击”确定”，此方法返回true，否则返回false。</p><h3 id="js的unshift-方法"><a href="#js的unshift-方法" class="headerlink" title="js的unshift() 方法"></a>js的unshift() 方法</h3><p>unshift() 可向数组的开头添加一个或更多元素，并返回新的长度。</p><p><strong>String、StringBuffer、StringBuilder的区别</strong></p><p>String是由final修饰，一旦被创建便不可更改，而StringBuilder和StringBuffer是可变的。</p><p>对于StringBuffer和StringBuilder来说区别不大，StringBuffer在方法上用synchronized修饰，是线程安全的，而StringBuilder是线程不安全的。</p><p><strong>HashMap的实现原理？什么场景下使用HashMap、LinkedHashMap、ConcurrentHashMap、WeakHashMap?哪些是线程安全的？</strong></p><p>hashMap的存储结构是由数组加链表/红黑树组成，采用Entry数组来存储key-value对，Entry类又是链表结构。根据key值通过哈希算法获取哈希值确定数组存储的位置，同一个哈希值下挂着链表，当链表的数量超过8时，链表转换成红黑树存储。</p><p>HashMap是以键值形式对存储对象，线程不安全且无序。在对顺序没有要求且单线程下使用。</p><p>LinkedHashMap的键值有序，但线程不安全。在单线程下对顺序有要求的场景使用。</p><p>ConcurrentHashMap是线程安全的Map，在多线程环境下使用。</p><p>WeakHashMap是线程不安全的，是基于弱引用，其对象可能随时被回收，适用于缓存的场景。</p><p><strong>synchronized和lock锁机制的异同</strong></p><p>异：</p><ol><li>synchronized可以加在方法上，也可以加在特定代码块上；lock需要显示地指定起始位置和终止位置。</li><li>synchronized是由JVM执行的；而lock的锁定是通过代码实现的，他有比synchronized更精确的线程语义和更好的性能。</li><li>synchronized获取锁和释放锁的方式都是在块结构中，当获取多个锁时，必须以相反的顺序释放，而且是自动解锁。而lock则需要开发人员手动释放锁，并且必须在finally中释放，否则会引起死锁。</li></ol><p>同：</p><p>lock能完成synchronized所实现的所有功能。</p><p><strong>JVM加载Class文件的原理机制？</strong></p><p>双亲委派机制：一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，只有父类加载器无法加载该类时，才会尝试从自己的类路径中加载该类。所以一个类在进行加载时，总是会先加载超类Object。</p><p><strong>JVM的内存结构及GC的工作原理？</strong></p><p>在JDK8中，JVM被划分成五个区域：堆、方法区、虚拟机栈、本地方法栈、程序计数器。</p><p>GC即为垃圾收集器。JVM中将对象的引用分为了四种类型，不同的对象引用类型GC会采用不同的方法进行回收：<br>（1）强引用：默认情况下，对象采用的均为强引用（GC不会回收）<br>（2）软引用：软引用是Java中提供的一种比较适合于缓存场景的应用（只有在内存不够用的情况下才会被GC）<br>（3）弱引用：在GC时一定会被GC回收<br>（4）虚引用：在GC时一定会被GC回收</p><p><strong>springMVC的实现原理？核心是什么？请求流程怎么处理？控制反转是怎么实现的？</strong></p><p>请求处理流程：</p><ol><li>客户端请求交给前端控制器；</li><li>前端控制器根据请求信息调用处理器映射器；</li><li>处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器并返回给前端控制器；</li><li>前端控制器调用处理器适配器；</li><li>处理器适配器调用合适的后端控制器 ；</li><li>后端控制器执行完成返回ModelAndView ；</li><li>前端控制器将ModelAndView传给视图解析器，解析后返回view；</li><li>前端控制器进行视图渲染并响应用户；</li></ol><p>五大核心组件：</p><p>　1.DispatcherServlet　　请求入口</p><p>　2.HandlerMapping　　  请求派发,负责请求和控制器建立一一对应的关系</p><p>　3.Controller　　　　　  处理器</p><p>　4.ModelAndView　　　  封装模型信息和视图信息</p><p>　5.ViewResolver　　　　视图处理器,定位页面</p><p>控制反转：</p><p>我们每次使用spring框架都要配置xml文件，这个xml配置了bean的id和class。</p><p>spring中默认的bean为单实例模式，通过bean的class引用反射机制可以创建这个实例。</p><p>因此，spring框架通过反射替我们创建好了实例并且替我们维护他们。</p><p>A需要引用B类，spring框架就会通过xml把B实例的引用传给了A的成员变量。</p><p><strong>从在浏览器地址中输入域名到数据返回发生了什么？</strong></p><ol><li>应用层DNS解析域名</li><li>应用层客户端发送HTTP请求</li><li>传输层TCP传输报文</li><li>网络层IP协议查询MAC地址</li><li>数据到达数据链路层</li><li>服务器接收数据</li><li>服务器处理请求</li><li>服务器返回相应文件</li></ol><p>解释三次握手，四次挥手以及为什么需要三次握手，四次挥手？</p><p>三次握手：</p><ol><li>客户端请求建立连接：SYN=1，seq=x；</li><li>服务器对客户端的请求进行响应：SYN=1，ACK=1，seq=y，ack=x+1；</li><li>客户端对服务器端的响应信息进行回应：ACK=1，seq=x+1，ack=y+1</li></ol><p>四次挥手：</p><ol><li>客户端请求断开连接： FIN=1，seq = u；</li><li>服务端对客户端的请求应答：ACK=1，seq=v，ack=u+1；</li><li>服务端请求断开连接：FIN=1，ACK=1，seq=w，ack=u+1；</li><li>客户端对服务端的请求应答：ACK=1，seq=u+1，ack=w+1</li></ol><p>TCP的核心思想是既要保证数据的可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求。</p><p>TCP连接握手，握的是什么？    </p><p>是通信双方数据远点的序列号！</p><p>双方都需要确认对方收到了自己的序列号！</p><p><strong>什么是线程和进程，有什么区别？</strong></p><p>进程是系统中正在运行的一个程序，程序一旦运行就是进程。</p><p>线程是进程的一个实体，是进程的一条执行路径。</p><p>一个进程可以拥有多个线程，每个线程使用其所属进程的栈空间</p><p>主要区别：</p><ol><li>不同进程间数据很难共享，同一进程下不同线程间数据很易共享</li><li>进程要比线程消耗更多的计算机资源</li><li>进程间不会相互影响，一个线程挂掉将导致整个进程挂掉</li><li>调度和切换：线程上下文切换比进程上下文切换快得多</li><li>在多线程OS中，进程不是一个可执行的实体</li><li>进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。－”互斥锁”</li><li>进程使用的内存地址可以限定使用量。－“信号量”</li></ol><p><strong>线程间常用的通信方法？</strong></p><ol><li>使用volatile关键字</li><li>使用Object类的wait() 和 notify() 方法</li><li>使用JUC工具类 CountDownLatch</li><li>使用 ReentrantLock 结合 Condition</li><li>基本LockSupport实现线程间的阻塞和唤醒</li></ol><p><strong>JDBC使用步骤</strong></p><ol><li>加载数据库驱动</li><li>通过DriverManager获取数据库连接</li><li>通过Connection对象创建Statement对象</li><li>使用Statement执行SQL语句</li><li>操作ResultSet结果集</li><li>回收数据库资源，包括关闭ResultSet、Statement和Connection等资源</li></ol><p><strong>JDBC的Statement、PerparStatement、CallableStatement的区别？</strong></p><p>Statement只允许执行写死的SQL语句；</p><p>PerparStatement可以允许执行带占位符的SQL语句，能有效防止SQL注入；</p><p>CallableStatement是用于调用存储过程；</p><p><strong>数据库隔离级别？各自含义？mysql的默认隔离级别？</strong></p><ol><li>Read Uncommit (读未提交)        脏读，不可重复读，幻读都不能避免</li><li>Read commit (读已提交)                能避免脏读，不能避免不可重复读，幻读</li><li>Repeatable Read (可重复读)          能避免脏读，不可重复读，不能避免幻读</li><li>Serialzable (可串行化)                     能避免脏读，不可重复读，幻读</li></ol><p>MySQL默认的存储引擎InnoDB默认的隔离级别为Repeatable Read (可重复读 )，而且InnoDB实现的Repeatable Read避免了幻读。</p><p><strong>数据库索引的实现原理？什么情况下索引会失效？</strong></p><p>索引是使用B+树实现的数据结构。索引的思想就是，根据表中的某个属性建立一套算法，每次查询的时候，在内存中根据该算法得到出所需要的数据的物理地址，根据物理地址直接去磁盘中拿到结果数据，不用将表中的所有数据都加载到内存扫描一遍。这有点类似于，我们查字典的时候，根据偏旁部首等信息对一个汉字进行页码定位（这个过程可以看做是索引的算法执行的过程），查到一个汉字的页码，根据该页码直接找到汉字所在的页，不需要把整个字典翻一遍。</p><p>索引失效的情况：</p><ol><li>如果条件中有or，即使其中有条件带索引也不会使用；</li><li>.对于多列索引，不是使用的第一部分，则不会使用索引；</li><li>like查询是以%开头，索引会失效；</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li></ol><p><strong>对java8中Stream API的理解？</strong></p><p>Stream 流是Java8中处理集合的关键抽象概念，它可以对集合进行非常复杂的查找、过滤、筛选等操作，在新版的JPA中，也已经加入了Stream。</p><p>Stream API的特点：</p><ol><li>Stream API的使用和同样是java8新特性的lambda表达式密不可分，可以大大提高编码效率和代码可读性。</li><li>Stream API提供串行和并行两种操作，其中并行操作能发挥多核处理器的优势，使用fork/join的方式进行并行操作以提高运行速度。</li><li>Stream API进行并行操作无需编写多线程代码即可写出高效的并发程序，且通常可避免多线程代码出错的问题。</li></ol><p><strong>java8中函数式接口的用途是什么？</strong></p><p>函数式接口也叫功能性接口，用来特指某类型接口，为Java 中Lambda的实现而定义。在lambda的实现过程中，java选择接口作为Lambda表达式的目标类型，有函数式接口就可以接受Lambda表达式作为函数式接口的实现，更多是为了简化代码。</p><p><strong>Stream流中间操作之map和flatMap的区别？</strong></p><p>从源码上看出：</p><p>map函数式接口抽象方法的返回值是R，flatMap函数式接口抽象方法返回值是Stream&lt; R &gt;</p><p>所以flatMap作用就是将返回的Stream&lt; R &gt;拆开，再组合每个值成新的Stream&lt; R &gt;，</p><p>即map只是一维 1对1 的映射，而flatmap可以将一个2维的集合映射成一个一维,相当于他映射的深度比map深了一层 </p><p><strong>常见的数据结构？常见的算法？</strong></p><p>线性表，链表，队列，栈，二叉树，图</p><p>递归算法，常见排序算法，分治法，贪心算法，动态规划算法</p><p>冒泡排序</p><p>交换排序</p><p>快速排序</p><p>希尔排序</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS布局</title>
      <link href="2020/09/03/css%E5%B8%83%E5%B1%80/"/>
      <url>2020/09/03/css%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp; 在我们写网页是，如果只想把所有内容都塞进一栏里，那么不用设置任何布局也是OK的。然而，如果用户把浏览器窗口调整的很大，这时阅读网页会非常难受：读完每一行之后，你的视觉焦点要从右到左移动一大段距离。</p><h2 id="1-CSS盒子模型"><a href="#1-CSS盒子模型" class="headerlink" title="1. CSS盒子模型"></a>1. CSS盒子模型</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素，下面的图片说明了盒子模型(Box Model)：</p><p><img src="/images/CSS/1599105548.jpg" class="lazyload" data-srcset="/images/CSS/1599105548.jpg" srcset="data:image/png;base64,666"></p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><blockquote><p>  一般我们不会用Content，而对于其他3种都有上下左右分别对应top、bottom、left、right。</p><p>  如果不想单独设置也可以直接用 margin：0px  10px 20px 30px;  这4个分别对应上 右 下 左的顺序。</p><p>  也可以 margin：10px 20px;  表示上下外边距各为10px，左右 边距各为20px。。。</p><p>  以此类推。</p></blockquote><h2 id="2-display显示"><a href="#2-display显示" class="headerlink" title="2. display显示"></a>2. display显示</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;display属性设置一个元素应如何显示，visibility属性指定一个元素应可见还是隐藏。</p><p><strong>&nbsp;&nbsp;&nbsp;&nbsp;隐藏一个元素可以通过把display属性设置为”none”，或把visibility属性设置为”hidden”。</strong></p><blockquote><p>  两者区别：</p><p>  visibility：hidden；隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局</p><p>  display：none；隐藏的元素不会占用任何空间</p></blockquote><p>display除了可以隐藏元素，还能设置元素的显示方式：</p><ul><li><strong>display：inline；  内联显示：元素在一列，不换行</strong></li><li><strong>display：block；  块显示：占用全部的宽度，前后都是换行符</strong></li></ul><blockquote><p>  将元素设置为块显示，设置元素的宽度，然后使用外边距 margin：0 auto；可使元素水平居中</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;    <span class="comment">/*可以根据需要设置上下外边距  margin: 50px auto； */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-position-定位"><a href="#3-position-定位" class="headerlink" title="3. position 定位"></a>3. position 定位</h2><p>position 属性的五个值：</p><ul><li><strong>static</strong>：默认值，不会受到受到 top, bottom, left, right影响。即没有定位，遵循正常顺序。</li><li><strong>fixed</strong>：相对于浏览器窗口是固定位置</li><li><strong>relative</strong>：相对定位。相对于其原本的正常位置进行移动</li><li><strong>absolute</strong>：绝对定位。相对于最近的已定位的父元素，如果元素没有已定位的父元素，那么它的位置相对于 <html></li><li><strong>sticky</strong>： 基于用户的滚动位置来定位。需要指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同</li></ul><h2 id="4-z-index-重叠"><a href="#4-z-index-重叠" class="headerlink" title="4. z-index 重叠"></a>4. z-index 重叠</h2><p>z-index属性指定了一个元素的堆叠顺序</p><p>一个元素可以有正数或负数的堆叠顺序。默认为0，数值大的在上层</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">top</span>:<span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">z-index</span>:-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-overflow-溢出"><a href="#5-overflow-溢出" class="headerlink" title="5. overflow 溢出"></a>5. overflow 溢出</h2><p>overflow：用来设置当元素的内容溢出其区域时发生的事情</p><p>overflow-y：指定如何处理顶部/底部边缘的内容溢出元素的内容区域</p><p>overflow-x：指定如何处理右边/左边边缘的内容溢出元素的内容区域</p><p>常用的属性值如下：</p><table><thead><tr><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>visible</td><td>默认值。内容不会被修剪，会呈现在元素框之外。</td></tr><tr><td>hidden</td><td>内容会被修剪，并且其余内容是不可见的。</td></tr><tr><td>scroll</td><td>内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td>auto</td><td>如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 overflow 属性的值。</td></tr></tbody></table><h2 id="6-flex-弹性布局"><a href="#6-flex-弹性布局" class="headerlink" title="6. flex 弹性布局"></a>6. flex 弹性布局</h2><p>弹性布局是CSS3的一种新布局模式，是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式，也就是自适应响应式。</p><p><strong>弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex有多个属性，常用的如下介绍。</p><h3 id="6-1-flex-direction"><a href="#6-1-flex-direction" class="headerlink" title="6.1 flex-direction"></a>6.1 flex-direction</h3><p><code>flex-direction</code> 属性指定了弹性子元素在父容器中的位置。用于指定子元素的排序顺序（水平或是垂直）</p><blockquote><p>  <strong>语法：</strong></p><p>  flex-direction：row | row-reverse | column | column-reverse</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: row-reverse；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex-direction的属性值：</p><ul><li>row：默认值。水平左起</li><li>row-reverse： 水平右起</li><li>column ： 垂直排序，从上往下</li><li>column-reverse： 垂直排序，从下往上</li></ul><h3 id="6-2-flex-wrap"><a href="#6-2-flex-wrap" class="headerlink" title="6.2 flex-wrap"></a>6.2 flex-wrap</h3><p><code>flex-wrap</code>  决定如果子元素超出父容器时是否换行，该如何换行。</p><blockquote><p>  语法：</p><p>  flex-wrap: wrap | nowrap | wrap-reverse</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-wrap</span>: wrap；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex-wrap的属性值：</p><ul><li>nowrap：默认值。不换行。</li><li>wrap：换行，第一行在上方。</li><li>wrap-reverse：换行，第一行在下方</li></ul><h3 id="6-3-flex-flow"><a href="#6-3-flex-flow" class="headerlink" title="6.3 flex-flow"></a>6.3 flex-flow</h3><p>flex-flow 其实是<code>flex-direction</code> 和 <code>flex-wrap</code> 的简写。****</p><blockquote><p>  <strong>例子：</strong></p><p>  flex-flow :  row-reverse  wrap;</p></blockquote><h3 id="6-4-justify-content"><a href="#6-4-justify-content" class="headerlink" title="6.4 justify-content"></a>6.4 justify-content</h3><p><code> justify-content</code> 用于设置元素在水平方向上的对齐方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>justify-content 的属性值：</p><ul><li>flex-start：默认值，左对齐</li><li>flex-end：右对齐</li><li>center：居中对齐</li><li>space-between：两端对齐，元素之间留白间隔相等</li><li>space-around：平均对齐，元素之前、之间、之后留白间隔相等</li></ul><h3 id="6-5-align-items"><a href="#6-5-align-items" class="headerlink" title="6.5 align-items"></a>6.5 align-items</h3><p><code>align-items</code> 用于设置元素在垂直方向上的对齐方式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>:center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>align-items 的属性值：</p><ul><li>stretch：默认值，元素被拉伸以适应容器。占满整个容器高度</li><li>center：中点对齐</li><li>flex-start：上端对齐</li><li>flex-end：下端对齐</li><li>baseline：第一行文字基线对齐</li></ul><hr><p>&nbsp;&nbsp;&nbsp;&nbsp;这里只是简单介绍了常用的布局所用到的方式和其属性值，具体的用法涉及代码这里没有给出，有需要的可以去具体学习网站。这里推荐 **菜鸟教程 **<a href="https://www.runoob.com/css/css-positioning.html">https://www.runoob.com/css/css-positioning.html</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> CSS布局 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收机制</title>
      <link href="2020/08/26/JVM-GC/"/>
      <url>2020/08/26/JVM-GC/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;程序计数器、虚拟机栈、本地方法栈 3 个区域随线程生灭(因为是线程私有)，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。而 Java <strong>堆和方法区</strong>则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期才知道那些对象会创建，这部分内存的分配和回收都是动态的，<strong>垃圾收集器所关注的就是这部分内存</strong>。</p><blockquote><p>  简而言之，垃圾收集器关注的是堆和方法区的内存。</p></blockquote><h2 id="1-对象标记"><a href="#1-对象标记" class="headerlink" title="1. 对象标记"></a>1. 对象标记</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;在进行垃圾回收之前，首先要确定的是哪些对象还“活着”，哪些对象已经“死去”。判断对象是否存活主要有以下2种算法：</p><h3 id="1-1-引用计数算法"><a href="#1-1-引用计数算法" class="headerlink" title="1.1 引用计数算法"></a>1.1 引用计数算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><blockquote><p>主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是<strong>它很难解决对象之间相互循环引用的问题</strong>。</p></blockquote><blockquote><p>举个例子：</p><p>对象objA和objB都有字段instance，赋值令objA.instance=objB及objB.instance=objA，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是它们因为互相引用着对方，导致它们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收它们。</p></blockquote><h3 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p><img src="/images/java/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.jpg" class="lazyload" data-srcset="/images/java/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNThiZmFjMTVjYTZkMzA3NmRlZjUxNzRlZDVjYTVhOTk_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.jpg" srcset="data:image/png;base64,666"></p><blockquote><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul></blockquote><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次逐渐减弱。</p><p>​    <strong>强引用：</strong>就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><p>​    <strong>软引用：</strong>是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p><p>​    <strong>弱引用：</strong>也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p><p>​    <strong>虚引用：</strong>也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK 1.2之后，提供了PhantomReference类来实现虚引用。</p><h3 id="1-4-生存还是死亡"><a href="#1-4-生存还是死亡" class="headerlink" title="1.4 生存还是死亡"></a>1.4 生存还是死亡</h3><blockquote><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时出于“缓刑”阶段，一个对象的真正死亡至少要经历两次标记过程：如果对象在进行中可达性分析后发现没有与 GC Roots 相连接的引用链，那他将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>如果这个对象被判定为有必要执行 finalize() 方法，那么这个对象竟会放置在一个叫做 F-Queue 的队列中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。这里所谓的“执行”是指虚拟机会出发这个方法，并不承诺或等待他运行结束。finalize() 方法是对象逃脱死亡命运的最后一次机会，稍后 GC 将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己 —— 只要重新与引用链上的任何一个对象简历关联即可。</p><p>值得注意的是，finalize() 方法只会被系统自动调用一次。如果对象面临下一次回收，它的finalize() 方法不会被再次执行。</p></blockquote><h3 id="1-5-回收方法区"><a href="#1-5-回收方法区" class="headerlink" title="1.5 回收方法区"></a>1.5 回收方法区</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在方法区进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，一次垃圾回收一般可以回收 70% ~ 95% 的空间，而永久代的垃圾收集效率远低于此。</p><p>永久代垃圾回收主要两部分内容：<strong>废弃的常量和无用的类</strong>。</p><blockquote><p>判断废弃常量：一般是判断没有该常量的引用。</p><p>判断无用的类，要同时满足以下三个条件：</p><ul><li>该类所有的实例都已经回收，也就是 Java 堆中不存在该类的任何实例</li><li>加载该类的 ClassLoader 已经被回收</li><li>该类对应的 java.lang.Class 对象没有任何地方呗引用，无法在任何地方通过反射访问该类的方法</li></ul></blockquote><hr><h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;垃圾收集算法是内存回收的方法论，常用的算法有以下四种：</p><h3 id="2-1-标记–清除算法"><a href="#2-1-标记–清除算法" class="headerlink" title="2.1 标记–清除算法"></a>2.1 标记–清除算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;如同它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p><p>两个不足：</p><ul><li>标记和清除两个过程的效率都不高</li><li>会产生大量不连续的内存碎片</li></ul><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h3><blockquote><p> 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p></blockquote><blockquote><p>只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点</p></blockquote><p>&nbsp;&nbsp;&nbsp;&nbsp;不过现在的商业虚拟机都采用这种收集算法来回收新生代，因为新生代中的对象98%是熬不过第一次GC的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;HotSpot虚拟机默认Eden和Survivor的大小比例一般是 8 : 1 : 1，每次浪费 10% 的 Survivor 空间。但是这里有一个问题就是如果存活的大于 10% 怎么办？这里采用一种分配担保策略：多出来的对象直接进入老年代。</p><h3 id="2-3-标记–整理算法"><a href="#2-3-标记–整理算法" class="headerlink" title="2.3 标记–整理算法"></a>2.3 标记–整理算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;是根据老年代的特点，提出的一种算法。进行标记之后，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><blockquote><p>算是对标记–清除算法的一种改进。</p></blockquote><h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;当前商业虚拟机的垃圾收集都采用“分代收集”算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是分为<strong>新生代</strong>和<strong>老年代</strong>，然后根据各个年代的特点制定相应的回收算法。</p><p>新生代：</p><blockquote><p>每次垃圾回收都有大量对象死去，只有少量存活，选用<code>复制算法</code>比较合理。</p></blockquote><p>老年代：</p><blockquote><p>老年代中对象存活率较高、没有额外的空间分配对它进行担保。所以必须使用 <code>标记--清除</code> 或者 <code>标记--整理</code> 算法回收。</p></blockquote><hr><h2 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3. 垃圾收集器"></a>3. 垃圾收集器</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;垃圾收集算法是内存回收的方法论，而垃圾收集器是内存回收的具体实现。</p><p>HotSpot虚拟机包含的所有收集器如下图：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="/images/java/1598431191.jpg" class="lazyload" data-srcset="/images/java/1598431191.jpg" srcset="data:image/png;base64,666" alt="11"/></div><span class="image-caption">11</span></div><blockquote><p>说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。</p></blockquote><h3 id="3-1-Serial-收集器"><a href="#3-1-Serial-收集器" class="headerlink" title="3.1 Serial 收集器"></a>3.1 Serial 收集器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这是一个单线程收集器。意味着它只会使用一个 CPU 或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" class="lazyload" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" srcset="data:image/png;base64,666"></p><blockquote><p>值得注意的是，实际上到现在为止，它依然是虚拟机运行在Client模式下的默认新生代收集器。</p><p>它有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比）</p></blockquote><blockquote><p>在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆的新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百多毫秒以内，只要不是频繁发生，这点停顿是可以接受的。所以，Serial收集器对于运行在Client模式下的虚拟机来说是一个很好的选择。</p></blockquote><h3 id="3-2-ParNew-收集器"><a href="#3-2-ParNew-收集器" class="headerlink" title="3.2 ParNew 收集器"></a>3.2 ParNew 收集器</h3><p><strong>ParNew收集器其实就是Serial收集器的多线程版本</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTU0NjVmYjJlMTdjYjVkNjY1YzI1YmI5OGFjZmVhOTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" class="lazyload" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMTU0NjVmYjJlMTdjYjVkNjY1YzI1YmI5OGFjZmVhOTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" srcset="data:image/png;base64,666"></p><blockquote><p>它是许多运行在Server模式下的虚拟机中首选的新生代收集器。</p><p>其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作</p></blockquote><h3 id="3-3-Parallel-Scavenge-收集器"><a href="#3-3-Parallel-Scavenge-收集器" class="headerlink" title="3.3 Parallel Scavenge 收集器"></a>3.3 Parallel Scavenge 收集器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这是一个新生代收集器，也是使用复制算法实现，同时也是并行的多线程收集器。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS 等收集器的关注点是尽可能地缩短垃圾收集时用户线程所停顿的时间，而 Parallel Scavenge 收集器的目的是达到一个可控制的吞吐量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">吞吐量&#x3D;运行用户代码时间&#x2F;（运行用户代码时间+垃圾收集时间）</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;作为一个吞吐量优先的收集器，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为GC自适应的调节策略(GC Ergonomics)。</p><h3 id="3-4-Serial-Old-收集器"><a href="#3-4-Serial-Old-收集器" class="headerlink" title="3.4 Serial Old 收集器"></a>3.4 Serial Old 收集器</h3><blockquote><p>是Serial收集器的老年代版本，单线程收集器，使用 <code>标记--整理</code> 算法</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" class="lazyload" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvYjE4NDk0YjFlNTQ4NTFiYmJkMmVlNTI3NjBjYzM3NTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" srcset="data:image/png;base64,666"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用；另一种用途就是作为CMS收集器的后备预案，在并发收集发生ConcurrentMode Failure时使用。</p><h3 id="3-5-Parallel-Old-收集器"><a href="#3-5-Parallel-Old-收集器" class="headerlink" title="3.5 Parallel Old 收集器"></a>3.5 Parallel Old 收集器</h3><blockquote><p>是 Parallel Scavenge 收集器的老年代版本，使用多线程和 <code>标记--整理</code> 算法。</p></blockquote><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjU2NDEzNjZiNDNkOTcxMzEwYTBhN2NlZGU0ZTQwNmE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" class="lazyload" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvMjU2NDEzNjZiNDNkOTcxMzEwYTBhN2NlZGU0ZTQwNmE_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" srcset="data:image/png;base64,666"></p><p>&nbsp;&nbsp;&nbsp;&nbsp;这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p><h3 id="3-6-CMS-收集器"><a href="#3-6-CMS-收集器" class="headerlink" title="3.6 CMS 收集器"></a>3.6 CMS 收集器</h3><blockquote><p>CMS (Concurrent Mark Sweep  并发标记清除 ) 收集器是一种以获取最短回收停顿时间为目标的收集器。基于 <code>标记--清除</code> 算法实现。</p></blockquote><p>运作步骤:</p><ol><li>初始标记(CMS initial mark)：标记 GC Roots 能直接关联到的对象</li><li>并发标记(CMS concurrent mark)：进行 GC Roots Tracing</li><li>重新标记(CMS remark)：修正并发标记期间的变动部分</li><li>并发清除(CMS concurrent sweep)</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmY0ZDY4MzY0NGExNTQ1MzdiM2UyM2Q2MGQ0OWMwNzQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" class="lazyload" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNmY0ZDY4MzY0NGExNTQ1MzdiM2UyM2Q2MGQ0OWMwNzQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" srcset="data:image/png;base64,666"></p><p>优点：并发收集、低停顿</p><p>缺点：对 CPU 资源敏感、无法收集浮动垃圾、 <code>标记 —— 清除</code> 算法带来的空间碎片</p><h3 id="3-7-G1-收集器"><a href="#3-7-G1-收集器" class="headerlink" title="3.7 G1 收集器"></a>3.7 G1 收集器</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，早在JDK 1.7刚刚确立项目目标，Sun公司给出的JDK 1.7 RoadMap里面，它就被视为JDK 1.7中HotSpot虚拟机的一个重要进化特征。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>G1是一款面向服务端应用的垃圾收集器。</strong></p><p>相比其他GC收集器，有如下特点：</p><ul><li><strong>并行与并发：</strong>G1能充分利用多CPU、多核环境下的硬件优势，缩短Stop-The-World停顿的时间</li><li><strong>分代收集：</strong>分代概念在G1中依然得以保留</li><li><strong>空间整合：</strong>G1运作期间不会产生内存空间碎片</li><li><strong>可预测的停顿：</strong>这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关<br>注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一<br>个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实<br>时Java（RTSJ）的垃圾收集器的特征了</li></ul><p>运作步骤:</p><ol><li><strong>初始标记(Initial Marking)：</strong>标记GC Roots能直接关联到的对象并且修改TAMS（Next Top at Mark Start）的值。<strong>需停顿线程，但耗时很短。</strong></li><li><strong>并发标记(Concurrent Marking)：</strong>进行可达性分析，找出存活的对象。耗时较长，但可与用户程序并发执行。</li><li><strong>最终标记(Final Marking)：</strong>修正并发标记期间的变动部分</li><li>筛选回收(Live Data Counting and Evacuation)</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNDBhNTc1OTMxYjI1NGE4ZjQwYmI1NDNjMjRlOGZhZGY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" class="lazyload" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvNDBhNTc1OTMxYjI1NGE4ZjQwYmI1NDNjMjRlOGZhZGY_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" srcset="data:image/png;base64,666"></p><h2 id="4-内存分配与回收策略"><a href="#4-内存分配与回收策略" class="headerlink" title="4. 内存分配与回收策略"></a>4. 内存分配与回收策略</h2><h3 id="4-1-对象优先在-Eden-分配"><a href="#4-1-对象优先在-Eden-分配" class="headerlink" title="4.1 对象优先在 Eden 分配"></a>4.1 对象优先在 Eden 分配</h3><blockquote><p>对象主要分配在新生代的 Eden 区上，如果启动了本地线程分配缓冲区，将线程优先在 (TLAB) 上分配。少数情况会直接分配在老年代中。</p></blockquote><p>一般来说 Java 堆的内存模型如下图所示：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" class="lazyload" data-srcset="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvOTcxMDE4MDMxNWQzNTc1NmI2OGU5YzVkYWY0NGQ2ZTU_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ" srcset="data:image/png;base64,666"></p><blockquote><ul><li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Full GC，经常会伴随至少一次的Minor GC（但非绝对的）。Full GC的速度一般会比Minor GC慢10倍以上。</li></ul></blockquote><h3 id="4-2-大对象直接进入老年代"><a href="#4-2-大对象直接进入老年代" class="headerlink" title="4.2 大对象直接进入老年代"></a>4.2 大对象直接进入老年代</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p><blockquote><p>大对象对虚拟机的内存分配来说就是一个坏消息（比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免），经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p></blockquote><h3 id="4-3-长期存活的对象将进入老年代"><a href="#4-3-长期存活的对象将进入老年代" class="headerlink" title="4.3 长期存活的对象将进入老年代"></a>4.3 长期存活的对象将进入老年代</h3><blockquote><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</p><p>对象晋升老年代的年龄阈值，可以通过参数-XX：MaxTenuringThreshold设置。</p></blockquote><h3 id="4-4-动态对象年龄判定"><a href="#4-4-动态对象年龄判定" class="headerlink" title="4.4 动态对象年龄判定"></a>4.4 动态对象年龄判定</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了年龄阈值才能晋升老年代，<strong>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到年龄阈值中要求的年龄</strong>。</p><blockquote><p>就比如说，假如Survivor空间大小为1MB，年龄同为5的A和B加起来的大小已经超过512KB，A对象和B对象以及年龄大于5的对象，直接晋升到老年代。</p></blockquote><h3 id="4-5-空间分配担保"><a href="#4-5-空间分配担保" class="headerlink" title="4.5 空间分配担保"></a>4.5 空间分配担保</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM垃圾回收 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM垃圾回收 </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存区域</title>
      <link href="2020/08/25/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>2020/08/25/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p>​    Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。从下面这张图可以看出来，Java数据区域分为五大数据区域<img src="/images/java/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.jpg" class="lazyload" data-srcset="/images/java/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGE3N2Q5MDE0Njc4NmMwY2IzZTE3MGI5YzkzNzZhZTQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.jpg" srcset="data:image/png;base64,666" alt="10006199-a4108d8fb7810a71"></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>​    程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><p><strong>为什么需要程序计数器？</strong></p><p>​    我们知道对于一个处理器(如果是多核cpu那就是一个内核)，在一个确定的时刻都只会执行一条线程中的指令。因此，为了线程切换可以恢复到正确执行位置，每个线程都需有独立的一个程序计器，不同线程之间的程序计数器互不影响，独立存储。<strong>我们称这类内存区域为“线程私有”的内存</strong>。</p><blockquote><p>注意：如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器值则为空。<strong>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError(OOM，内存溢出异常)情况的区域。</strong></p></blockquote><h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p>​    与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：<strong>每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</strong></p><blockquote><p>​    在Java虚拟机规范中，对这个区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p></blockquote><p>我们常说的栈就是虚拟机栈，或者说是虚拟机中局部变量表部分。</p><p>局部变量表存放的是编译期可知的<strong>8种基本数据类型</strong>、<strong>对象引用</strong>和<strong>返回地址类型</strong>。(其中64位长度的long和double会占2个局部变量空间，其他的数据类型只占1个)</p><p><img src="/images/java/10683-20190506140027109-1164414945.jpg" class="lazyload" data-srcset="/images/java/10683-20190506140027109-1164414945.jpg" srcset="data:image/png;base64,666"></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​    本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p><blockquote><p>此区域也会抛出StackOverflowError和OutOfMemoryError异常</p></blockquote><h3 id="java堆"><a href="#java堆" class="headerlink" title="java堆"></a>java堆</h3><p>​    对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被<strong>所有线程共享的</strong>一块内存区域，在虚拟机启动时创建（<strong>也就是说，在JVM中只有一个堆</strong>）。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>​    这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p><blockquote><p>根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p></blockquote><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>​    方法区与Java堆一样，<strong>是各个线程共享的内存区域</strong>，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。</p><blockquote><p>根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p></blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p><strong>运行时常量池</strong></p><p>​    是属于方法区的一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() 方法生成的常量)都可以将常量放入池中。</p><blockquote><p>内存有限，无法申请时抛出 OutOfMemoryError。</p></blockquote><p><strong>直接内存</strong></p><blockquote><p> 不是虚拟机运行时数据区的一部分，但会被频繁地使用。</p></blockquote><p>​    在 JDK 1.4 中新加入 NIO (New Input/Output) 类，引入了一种基于通道(Channel)和缓存(Buffer)的 I/O 方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。可以避免在 Java 堆和 Native 堆中来回的数据耗时操作。<br>OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>​    虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。</p><p>​    在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。</p><p>而根据java堆中的内存是否规整，为对象分配内存的方式分为以下2种：</p><p><strong>指针碰撞</strong></p><p>​    假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。</p><p><strong>空闲列表</strong></p><p>​    如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。</p><blockquote><p>因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器时，通常采用空闲列表。</p><p>垃圾回收过程请参考其他文章。</p></blockquote><p>除了考虑如何划分空间之外，还需要考虑一个<strong>线程安全问题</strong>。解决这个问题有两种方案：</p><p>​    一种是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</p><p>​    另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为<strong>本地线程分配缓冲</strong>（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。</p><p>​    内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p><p>​    接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</p><p>​    在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始——＜init＞方法还没有执行，所有的字段都还为零。执行new指令之后会接着执行＜init＞方法，这样一个真正可用的对象就完全产生出来。</p><blockquote><p>简单地说，对象的创建的步骤：为对象分配内存空间 –&gt; 对分配的空间初始化为零 –&gt; 对对象进行必要的设置 –&gt; 数据初始化</p></blockquote><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 HotSpot 虚拟机中，分为 3 块区域：<code>对象头(Header)</code>、<code>实例数据(Instance Data)</code>和<code>对齐填充(Padding)</code></p><p><code>对象头(Header)</code> ：包含两部分，<strong>第一部分用于存储对象自身的运行时数据</strong>，如哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，32 位虚拟机占 32 bit，64 位虚拟机占 64 bit。官方称为 ‘Mark Word’。<strong>第二部分是类型指针</strong>，即对象指向它的类的元数据指针，虚拟机通过这个指针确定这个对象是哪个类的实例。另外，如果是 Java 数组，对象头中还必须有一块用于记录数组长度的数据，因为普通对象可以通过 Java 对象元数据确定大小，而数组对象不可以。</p><p><code>实例数据(Instance Data)</code>：程序代码中所定义的各种类型的字段内容(包含父类继承下来的和子类中定义的)。</p><p><code>对齐填充(Padding)</code>：不是必然需要，主要是占位，保证对象大小是某个字节的整数倍。</p><p><strong>对象的访问定位</strong></p><p>​    对象的使用，是通过栈上的引用数据来操作堆上的具体对象。栈对堆的访问方式，主流的有2种：</p><p><strong>使用句柄访问</strong></p><p>​    Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如图：</p><p><img src="/images/java/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZWJmMDBlZDI2YzM1YWVmZDkzZDVhM2EzNmIzYjE2MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.jpg" class="lazyload" data-srcset="/images/java/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZWJmMDBlZDI2YzM1YWVmZDkzZDVhM2EzNmIzYjE2MTM_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.jpg" srcset="data:image/png;base64,666"></p><p><strong>使用直接指针访问</strong></p><p>​    Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。如图：</p><p><img src="/images/java/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGU2OTI0YjZlOWQ1NzYxMDViYTI0NzAwZjFmMzU3ZjQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.jpg" class="lazyload" data-srcset="/images/java/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxNy85LzQvZGU2OTI0YjZlOWQ1NzYxMDViYTI0NzAwZjFmMzU3ZjQ_aW1hZ2VWaWV3Mi8wL3cvMTI4MC9oLzk2MC9mb3JtYXQvd2VicC9pZ25vcmUtZXJyb3IvMQ.jpg" srcset="data:image/png;base64,666"></p><blockquote><p><strong>两者比较：</strong></p><p>使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。</p><p>直接指针访问的最大好处是速度快，节省了一次指针定位的时间开销。如果是对象频繁 GC 那么句柄方法好，如果是对象频繁访问则直接指针访问好。</p><p><strong>对于虚拟机Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。</strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> java内存区域 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM内存区域 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八大排序算法</title>
      <link href="2020/08/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
      <url>2020/08/21/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>基本思路：两两比较相邻记录的数，如果反序则交换，直到没有反序的记录为止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> srr[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; srr.length &amp;&amp; flag; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            flag = <span class="keyword">false</span>;    <span class="comment">//一轮下来没有交换，说明已经排好，退出循环</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = srr.length-<span class="number">1</span>; j &gt;i; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span>(srr[j] &lt; srr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(srr,j-<span class="number">1</span>,j);</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p>基本思想：通过n-i次数值间的比较，从n-i-1个记录中选出最小值位置，并个第i个位置交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> arr[])</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            min = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(arr[min] &gt; arr[j]) &#123;    <span class="comment">//每次和标记的最小值相比</span></span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min != i) &#123;</span><br><span class="line">                swap(arr, min, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>基本思想：将一个记录插入到排序好的有序表中，从而得到一个新的、记录增1的有序表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> ins[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i,j,temp;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; ins.length; i++) &#123;</span><br><span class="line">            temp = ins[i]; <span class="comment">// 保存每次需要插入的那个数</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; ins[j - <span class="number">1</span>] &gt; temp; j--) &#123; <span class="comment">// 这个较上面有一定的优化</span></span><br><span class="line">                ins[j] = ins[j - <span class="number">1</span>]; <span class="comment">// 把大于需要插入的数往后移动。最后不大于temp的数就空出来j</span></span><br><span class="line">            &#125;</span><br><span class="line">            ins[j] = temp; <span class="comment">// 将需要插入的数放入这个位置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
