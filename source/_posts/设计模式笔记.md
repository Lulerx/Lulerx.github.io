---
title: 常见设计模式
categories: 设计模式    #分类
tags: 设计模式         #标签
toc: true  #是否启用内容索引
---



## 单例模式

### 定义和特点

定义：所谓单例，就是整个程序有且仅有一个实例。

特点：

+ 类构造器私有
+ 持有自己类型的属性
+ 对外提供获取实例的静态方法

### 优缺点

优点：

1. 提供了对唯一实例的受控访问；
2. 节省系统资源。由于系统中内存只存在一个对象，因此可以节约资源的资源，对于一些繁琐的创建和销毁的对象，单例模式无意中可以提高系统的性能；
3. 单例模式允许可变的数目的实例，使用单利模式进行扩展，使用控制单利对象相似的方法可以获取指定个数的实例，及解决了单利对象共享过多，而有损性能的问题。

缺点：

1. 由于单例模式不是抽象的，所有可扩展性比较差。
2. 单例类，职责过重，在一定程度上违背了单一职责原则
3. 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。

### 饿汉式

~~~java
public class Singleton {  
  	// 1.在类的内部创建自行实例,持有自己类型的属性
    private static Singleton instance = new Singleton();
  	// 2.将构造函数私有化，不可以通过new的方式来创建对象
    private Singleton (){}  
  	// 3.提供获取唯一实例的静态方法
    public static Singleton getInstance() {  
    	return instance;  
    }  
}
~~~

一上来就创建对象，线程安全，比较常用，但是容易产生垃圾，**因为如果该实例从始至终都没被使用过，则会造成内存浪费**

### 懒汉式

~~~java
public class Singleton {  
  	//持有自己类型的属性，先不创建对象，用到时再创建
    private static Singleton instance;  
  	//构造器私有化
    private Singleton (){}  
  	//对外提供获取实例的静态方法(多线程环境下加锁)
    public static synchronized Singleton getInstance() { 
      	// 用到时如果这个对象引用为null，我们就创建并返回出去
    	if (instance == null) {  
        	instance = new Singleton();  
    	}  
    	return instance;  
    }  
}
~~~

线程不安全，使用synchronized加锁；但是直接在方法上加锁的方式其实不够好，在多线程环境下性能会比较低，下面是**双重检测机制(DCL)懒汉式**

### 双重检测机制(DCL)懒汉式

```java
public class Singleton {  
    private volatile static Singleton singleton;  // volatile实现内存可见性
    private Singleton (){}  
    public static Singleton getSingleton() {  
    	if (singleton == null) {  //此处判断是为了提高性能
        	synchronized (Singleton.class) {  //同步代码块进行线程加锁
        		if (singleton == null) {  
            		singleton = new Singleton();  
        		}  
        	}  
    	}  
    return singleton;  
    }  
}
```

双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。由于`singleton singleton = new Singleton()`对象的创建在JVM中可能会进行重排序，在多线程访问下存在风险，使用`volatile`修饰`signleton`实例变量有效，解决该问题。

### 静态内部类懒汉式

~~~java
public class Singleton { 
    private Singleton(){
    }
      public static Singleton getInstance(){  
        return Inner.instance;  
    }  
    private static class Inner {  
        private static final Singleton instance = new Singleton();  
    }  
} 
~~~

只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。**目前此方式是所有单例模式中最推荐的模式**，但具体还是根据项目选择。

---



众所周知，单例模式是创建型模式，都会新建一个实例。那么一个重要的问题就是反序列化。当实例被写入到文件到反序列化成实例时，我们需要重写`readResolve`方法，以让实例唯一。

~~~java
private Object readResolve() throws ObjectStreamException{
        return singleton;
}
~~~



## 适配器模式

### 定义

适配器主要用于接口的转换或者将接口不兼容的类对象组合在一起形成对外统一接口，是一种结构性模式，其本质是是一个中间件，适用于类及其对象。

### 适用场景

1. 想用一个已经存在的类，但其接口不符合需求；
2. 想创建一个可以复用的类，该类可以与其他不相关的类协同工作；
3. 想使用一些已经存在的子类，但是不能对每一个都进行子类化以匹配它们的接口（仅适用于对象Adapter）。对象适配器可以适配他的父类接口。

### 优缺点

**优点**

1. 提高了类的复用；
2. 组合若干关联对象形成对外提供统一服务的接口；
3. 扩展性、灵活性好。

**缺点**

1. 过多使用适配模式容易造成代码功能和逻辑意义的混淆。
2. 部分语言对继承的限制，可能至多只能适配一个适配者类，而且目标类必须是抽象类。



